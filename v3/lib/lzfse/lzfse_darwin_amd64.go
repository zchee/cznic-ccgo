// Code generated by 'v3 -host-config-opts=-std=c2x,-march=native,-mtune=skylake-avx512,-arch=x86_64,-m64 -err-trace -pkgname=lzfse -trace-translation-units -hide=fse_extract_bits64 -o lib/lzfse/lzfse_darwin_amd64.go -I~/src/github.com/lzfse/lzfse/src -DHAVE_LABELS_AS_VALUES=0 /Users/zchee/src/github.com/lzfse/lzfse/src/lzvn_decode_base.c /Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_encode.c /Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_decode_base.c /Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_decode.c /Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_fse.c /Users/zchee/src/github.com/lzfse/lzfse/src/lzvn_encode_base.c /Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_encode_base.c', DO NOT EDIT.

package lzfse

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
const ( /* wait.h:79:1: */
	P_ALL  = 0
	P_PID  = 1
	P_PGID = 2
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

var __darwin_check_fd_set_overflow uintptr /* <builtin>:146:5: */

func __builtin_ctzll(tls *libc.TLS, mask int64) int32 { /* <builtin>:149:1: */
	var bit int32

	if mask == int64(0) {
		return 0
	}
	for bit = 1; !(mask&int64(1) != 0); bit++ {
		mask = int64(uint64(mask) >> 1)
	}
	return bit
}

func __builtin_ctzl(tls *libc.TLS, mask int64) int32 { /* <builtin>:161:1: */
	var bit int32

	if mask == int64(0) {
		return 0
	}
	for bit = 1; !(mask&int64(1) != 0); bit++ {
		mask = int64(uint64(mask) >> 1)
	}
	return bit
}

// ===---- __stddef_max_align_t.h - Definition of max_align_t for modules ---===
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===-----------------------------------------------------------------------===

type max_align_t = float64 /* __stddef_max_align_t.h:16:21 */

// Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
// __WINT_TYPE__ directly; accommodate both by requiring __need_wint_t

//===---- stdint.h - Standard header for sized integer types --------------===* *
//  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://llvm.org/LICENSE.txt for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// \*===----------------------------------------------------------------------===

// AIX system headers need stdint.h to be re-enterable while _STD_TYPES_T
// is defined until an inclusion of it without _STD_TYPES_T occurs, in which
// case the header guard macro is defined.

// If we're hosted, fall back to the system's stdint.h, which might have
// additional definitions.

// C99 7.18.1.1 Exact-width integer types.
// C99 7.18.1.2 Minimum-width integer types.
// C99 7.18.1.3 Fastest minimum-width integer types.
//
// The standard requires that exact-width type be defined for 8-, 16-, 32-, and
// 64-bit types if they are implemented. Other exact width types are optional.
// This implementation defines an exact-width types for every integer width
// that is represented in the standard integer types.
//
// The standard also requires minimum-width types be defined for 8-, 16-, 32-,
// and 64-bit widths regardless of whether there are corresponding exact-width
// types.
//
// To accommodate targets that are missing types that are exactly 8, 16, 32, or
// 64 bits wide, this implementation takes an approach of cascading
// redefinitions, redefining __int_leastN_t to successively smaller exact-width
// types. It is therefore important that the types are defined in order of
// descending widths.
//
// We currently assume that the minimum-width types and the fastest
// minimum-width types are the same. This is allowed by the standard, but is
// suboptimal.
//
// In violation of the standard, some targets do not implement a type that is
// wide enough to represent all of the required widths (8-, 16-, 32-, 64-bit).
// To accommodate these targets, a required minimum-width type is only
// defined if there exists an exact-width type of equal or greater width.

type int64_t = int64   /* stdint.h:96:24 */
type uint64_t = uint64 /* stdint.h:98:25 */

type int_least64_t = int64_t   /* stdint.h:110:25 */
type uint_least64_t = uint64_t /* stdint.h:111:26 */
type int_fast64_t = int64_t    /* stdint.h:112:25 */
type uint_fast64_t = uint64_t  /* stdint.h:113:26 */

type int32_t = int32 /* stdint.h:167:24 */

type uint32_t = uint32 /* stdint.h:172:25 */

type int_least32_t = int32_t   /* stdint.h:184:25 */
type uint_least32_t = uint32_t /* stdint.h:185:26 */
type int_fast32_t = int32_t    /* stdint.h:186:25 */
type uint_fast32_t = uint32_t  /* stdint.h:187:26 */

type int16_t = int16   /* stdint.h:205:24 */
type uint16_t = uint16 /* stdint.h:207:25 */

type int_least16_t = int16_t   /* stdint.h:215:25 */
type uint_least16_t = uint16_t /* stdint.h:216:26 */
type int_fast16_t = int16_t    /* stdint.h:217:25 */
type uint_fast16_t = uint16_t  /* stdint.h:218:26 */

type int8_t = int8   /* stdint.h:224:23 */
type uint8_t = uint8 /* stdint.h:226:24 */

type int_least8_t = int8_t   /* stdint.h:232:24 */
type uint_least8_t = uint8_t /* stdint.h:233:25 */
type int_fast8_t = int8_t    /* stdint.h:234:24 */
type uint_fast8_t = uint8_t  /* stdint.h:235:25 */

// prevent glibc sys/types.h from defining conflicting types

// C99 7.18.1.4 Integer types capable of holding object pointers.

type intptr_t = int64 /* stdint.h:249:25 */

type uintptr_t = uint64 /* stdint.h:256:26 */

// C99 7.18.1.5 Greatest-width integer types.
type intmax_t = int64   /* stdint.h:262:26 */
type uintmax_t = uint64 /* stdint.h:263:26 */

// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// pthread opaque structures

type __darwin_pthread_handler_rec = struct {
	__routine uintptr
	__arg     uintptr
	__next    uintptr
} /* _pthread_types.h:57:1 */

type _opaque_pthread_attr_t = struct {
	__sig    int64
	__opaque [56]int8
} /* _pthread_types.h:63:1 */

type _opaque_pthread_cond_t = struct {
	__sig    int64
	__opaque [40]int8
} /* _pthread_types.h:68:1 */

type _opaque_pthread_condattr_t = struct {
	__sig    int64
	__opaque [8]int8
} /* _pthread_types.h:73:1 */

type _opaque_pthread_mutex_t = struct {
	__sig    int64
	__opaque [56]int8
} /* _pthread_types.h:78:1 */

type _opaque_pthread_mutexattr_t = struct {
	__sig    int64
	__opaque [8]int8
} /* _pthread_types.h:83:1 */

type _opaque_pthread_once_t = struct {
	__sig    int64
	__opaque [8]int8
} /* _pthread_types.h:88:1 */

type _opaque_pthread_rwlock_t = struct {
	__sig    int64
	__opaque [192]int8
} /* _pthread_types.h:93:1 */

type _opaque_pthread_rwlockattr_t = struct {
	__sig    int64
	__opaque [16]int8
} /* _pthread_types.h:98:1 */

type _opaque_pthread_t = struct {
	__sig           int64
	__cleanup_stack uintptr
	__opaque        [8176]int8
} /* _pthread_types.h:103:1 */

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
type idtype_t = uint32 /* wait.h:83:3 */

// [XSI] The id_t and pid_t types shall be defined as described
// in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type pid_t = int32 /* _pid_t.h:31:31 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type id_t = uint32 /* _id_t.h:31:25 */ // can hold pid_t, gid_t, or uid_t

// [XSI] The siginfo_t type shall be defined as described in <signal.h>
// [XSI] The rusage structure shall be defined as described in <sys/resource.h>
// [XSI] Inclusion of the <sys/wait.h> header may also make visible all
// symbols from <signal.h> and <sys/resource.h>
//
// NOTE:	This requirement is currently being satisfied by the direct
//		inclusion of <sys/signal.h> and <sys/resource.h>, below.
//
//		Software should not depend on the exposure of anything other
//		than the types siginfo_t and struct rusage as a result of
//		this inclusion.  If you depend on any types or manifest
//		values othe than siginfo_t and struct rusage from either of
//		those files, you should explicitly include them yourself, as
//		well, or in future releases your stware may not compile
//		without modification.
// Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.2 (Berkeley) 1/21/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1992 NeXT Computer, Inc.
//

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

type sig_atomic_t = int32 /* signal.h:41:13 */

// Copyright (c) 2016 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type u_int8_t = uint8 /* _u_int8_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type u_int16_t = uint16 /* _u_int16_t.h:30:41 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type u_int32_t = uint32 /* _u_int32_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type u_int64_t = uint64 /* _u_int64_t.h:30:33 */

type register_t = int64_t /* types.h:90:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// These types are used for reserving the largest possible size.
type user_addr_t = u_int64_t  /* types.h:100:33 */
type user_size_t = u_int64_t  /* types.h:101:33 */
type user_ssize_t = int64_t   /* types.h:102:33 */
type user_long_t = int64_t    /* types.h:103:33 */
type user_ulong_t = u_int64_t /* types.h:104:33 */
type user_time_t = int64_t    /* types.h:105:33 */
type user_off_t = int64_t     /* types.h:106:33 */

// This defines the size of syscall arguments after copying into the kernel:
type syscall_arg_t = u_int64_t /* types.h:114:33 */

// i386 is the structure that is exported to user threads for
// use in status/mutate calls.  This structure should never change.
//

type __darwin_i386_thread_state = struct {
	__eax    uint32
	__ebx    uint32
	__ecx    uint32
	__edx    uint32
	__edi    uint32
	__esi    uint32
	__ebp    uint32
	__esp    uint32
	__ss     uint32
	__eflags uint32
	__eip    uint32
	__cs     uint32
	__ds     uint32
	__es     uint32
	__fs     uint32
	__gs     uint32
} /* _structs.h:48:1 */

// This structure should be double-word aligned for performance

type __darwin_fp_control = struct {
	_         [0]uint16
	__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
} /* _structs.h:94:1 */

// Status word.

type __darwin_fp_status = struct {
	_         [0]uint16
	__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
} /* _structs.h:152:1 */

// defn of 80bit x87 FPU or MMX register

type __darwin_mmst_reg = struct {
	__mmst_reg  [10]int8
	__mmst_rsrv [6]int8
} /* _structs.h:196:1 */

// defn of 128 bit XMM regs

type __darwin_xmm_reg = struct{ __xmm_reg [16]int8 } /* _structs.h:215:1 */

// defn of 256 bit YMM regs

type __darwin_ymm_reg = struct{ __ymm_reg [32]int8 } /* _structs.h:231:1 */

// defn of 512 bit ZMM regs

type __darwin_zmm_reg = struct{ __zmm_reg [64]int8 } /* _structs.h:247:1 */

type __darwin_opmask_reg = struct{ __opmask_reg [8]int8 } /* _structs.h:261:1 */

// Floating point state.

type __darwin_i386_float_state = struct {
	__fpu_reserved [2]int32
	__fpu_fcw      struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	__fpu_fsw struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm1 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm2 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm3 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm4 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm5 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm6 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm7 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_xmm0      struct{ __xmm_reg [16]int8 }
	__fpu_xmm1      struct{ __xmm_reg [16]int8 }
	__fpu_xmm2      struct{ __xmm_reg [16]int8 }
	__fpu_xmm3      struct{ __xmm_reg [16]int8 }
	__fpu_xmm4      struct{ __xmm_reg [16]int8 }
	__fpu_xmm5      struct{ __xmm_reg [16]int8 }
	__fpu_xmm6      struct{ __xmm_reg [16]int8 }
	__fpu_xmm7      struct{ __xmm_reg [16]int8 }
	__fpu_rsrv4     [224]int8
	__fpu_reserved1 int32
} /* _structs.h:283:1 */

type __darwin_i386_avx_state = struct {
	__fpu_reserved [2]int32
	__fpu_fcw      struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	__fpu_fsw struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm1 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm2 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm3 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm4 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm5 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm6 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm7 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_xmm0      struct{ __xmm_reg [16]int8 }
	__fpu_xmm1      struct{ __xmm_reg [16]int8 }
	__fpu_xmm2      struct{ __xmm_reg [16]int8 }
	__fpu_xmm3      struct{ __xmm_reg [16]int8 }
	__fpu_xmm4      struct{ __xmm_reg [16]int8 }
	__fpu_xmm5      struct{ __xmm_reg [16]int8 }
	__fpu_xmm6      struct{ __xmm_reg [16]int8 }
	__fpu_xmm7      struct{ __xmm_reg [16]int8 }
	__fpu_rsrv4     [224]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
} /* _structs.h:320:1 */

type __darwin_i386_avx512_state = struct {
	__fpu_reserved [2]int32
	__fpu_fcw      struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	__fpu_fsw struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm1 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm2 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm3 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm4 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm5 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm6 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm7 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_xmm0      struct{ __xmm_reg [16]int8 }
	__fpu_xmm1      struct{ __xmm_reg [16]int8 }
	__fpu_xmm2      struct{ __xmm_reg [16]int8 }
	__fpu_xmm3      struct{ __xmm_reg [16]int8 }
	__fpu_xmm4      struct{ __xmm_reg [16]int8 }
	__fpu_xmm5      struct{ __xmm_reg [16]int8 }
	__fpu_xmm6      struct{ __xmm_reg [16]int8 }
	__fpu_xmm7      struct{ __xmm_reg [16]int8 }
	__fpu_rsrv4     [224]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
	__fpu_k0        struct{ __opmask_reg [8]int8 }
	__fpu_k1        struct{ __opmask_reg [8]int8 }
	__fpu_k2        struct{ __opmask_reg [8]int8 }
	__fpu_k3        struct{ __opmask_reg [8]int8 }
	__fpu_k4        struct{ __opmask_reg [8]int8 }
	__fpu_k5        struct{ __opmask_reg [8]int8 }
	__fpu_k6        struct{ __opmask_reg [8]int8 }
	__fpu_k7        struct{ __opmask_reg [8]int8 }
	__fpu_zmmh0     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh1     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh2     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh3     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh4     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh5     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh6     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh7     struct{ __ymm_reg [32]int8 }
} /* _structs.h:366:1 */

type __darwin_i386_exception_state = struct {
	__trapno     uint16
	__cpu        uint16
	__err        uint32
	__faultvaddr uint32
} /* _structs.h:577:1 */

type __darwin_x86_debug_state32 = struct {
	__dr0 uint32
	__dr1 uint32
	__dr2 uint32
	__dr3 uint32
	__dr4 uint32
	__dr5 uint32
	__dr6 uint32
	__dr7 uint32
} /* _structs.h:597:1 */

type __x86_instruction_state = struct {
	__insn_stream_valid_bytes int32
	__insn_offset             int32
	__out_of_synch            int32
	__insn_bytes              [2380]uint8
	__insn_cacheline          [64]uint8
} /* _structs.h:610:1 */

type __last_branch_record = struct {
	__from_ip    uint64
	__to_ip      uint64
	__mispredict uint32 /* __uint32_t __mispredict: 1, __uint32_t __tsx_abort: 1, __uint32_t __in_tsx: 1, __uint32_t __cycle_count: 16, __uint32_t __reserved: 13 */
	_            [4]byte
} /* _structs.h:626:1 */

type __last_branch_state = struct {
	__lbr_count         int32
	__lbr_supported_tsx uint32 /* __uint32_t __lbr_supported_tsx: 1, __uint32_t __lbr_supported_cycle_count: 1, __uint32_t __reserved: 30 */
	_                   [8]byte
	__lbrs              [32]struct {
		__from_ip    uint64
		__to_ip      uint64
		__mispredict uint32 /* __uint32_t __mispredict: 1, __uint32_t __tsx_abort: 1, __uint32_t __in_tsx: 1, __uint32_t __cycle_count: 16, __uint32_t __reserved: 13 */
		_            [4]byte
	}
} /* _structs.h:638:1 */

type __x86_pagein_state = struct{ __pagein_error int32 } /* _structs.h:704:1 */

// 64 bit versions of the above

type __darwin_x86_thread_state64 = struct {
	__rax    uint64
	__rbx    uint64
	__rcx    uint64
	__rdx    uint64
	__rdi    uint64
	__rsi    uint64
	__rbp    uint64
	__rsp    uint64
	__r8     uint64
	__r9     uint64
	__r10    uint64
	__r11    uint64
	__r12    uint64
	__r13    uint64
	__r14    uint64
	__r15    uint64
	__rip    uint64
	__rflags uint64
	__cs     uint64
	__fs     uint64
	__gs     uint64
} /* _structs.h:715:1 */

// 64 bit versions of the above (complete)

type __darwin_x86_thread_full_state64 = struct {
	__ss64 struct {
		__rax    uint64
		__rbx    uint64
		__rcx    uint64
		__rdx    uint64
		__rdi    uint64
		__rsi    uint64
		__rbp    uint64
		__rsp    uint64
		__r8     uint64
		__r9     uint64
		__r10    uint64
		__r11    uint64
		__r12    uint64
		__r13    uint64
		__r14    uint64
		__r15    uint64
		__rip    uint64
		__rflags uint64
		__cs     uint64
		__fs     uint64
		__gs     uint64
	}
	__ds     uint64
	__es     uint64
	__ss     uint64
	__gsbase uint64
} /* _structs.h:773:1 */

type __darwin_x86_float_state64 = struct {
	__fpu_reserved [2]int32
	__fpu_fcw      struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	__fpu_fsw struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm1 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm2 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm3 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm4 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm5 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm6 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm7 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_xmm0      struct{ __xmm_reg [16]int8 }
	__fpu_xmm1      struct{ __xmm_reg [16]int8 }
	__fpu_xmm2      struct{ __xmm_reg [16]int8 }
	__fpu_xmm3      struct{ __xmm_reg [16]int8 }
	__fpu_xmm4      struct{ __xmm_reg [16]int8 }
	__fpu_xmm5      struct{ __xmm_reg [16]int8 }
	__fpu_xmm6      struct{ __xmm_reg [16]int8 }
	__fpu_xmm7      struct{ __xmm_reg [16]int8 }
	__fpu_xmm8      struct{ __xmm_reg [16]int8 }
	__fpu_xmm9      struct{ __xmm_reg [16]int8 }
	__fpu_xmm10     struct{ __xmm_reg [16]int8 }
	__fpu_xmm11     struct{ __xmm_reg [16]int8 }
	__fpu_xmm12     struct{ __xmm_reg [16]int8 }
	__fpu_xmm13     struct{ __xmm_reg [16]int8 }
	__fpu_xmm14     struct{ __xmm_reg [16]int8 }
	__fpu_xmm15     struct{ __xmm_reg [16]int8 }
	__fpu_rsrv4     [96]int8
	__fpu_reserved1 int32
} /* _structs.h:796:1 */

type __darwin_x86_avx_state64 = struct {
	__fpu_reserved [2]int32
	__fpu_fcw      struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	__fpu_fsw struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm1 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm2 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm3 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm4 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm5 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm6 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm7 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_xmm0      struct{ __xmm_reg [16]int8 }
	__fpu_xmm1      struct{ __xmm_reg [16]int8 }
	__fpu_xmm2      struct{ __xmm_reg [16]int8 }
	__fpu_xmm3      struct{ __xmm_reg [16]int8 }
	__fpu_xmm4      struct{ __xmm_reg [16]int8 }
	__fpu_xmm5      struct{ __xmm_reg [16]int8 }
	__fpu_xmm6      struct{ __xmm_reg [16]int8 }
	__fpu_xmm7      struct{ __xmm_reg [16]int8 }
	__fpu_xmm8      struct{ __xmm_reg [16]int8 }
	__fpu_xmm9      struct{ __xmm_reg [16]int8 }
	__fpu_xmm10     struct{ __xmm_reg [16]int8 }
	__fpu_xmm11     struct{ __xmm_reg [16]int8 }
	__fpu_xmm12     struct{ __xmm_reg [16]int8 }
	__fpu_xmm13     struct{ __xmm_reg [16]int8 }
	__fpu_xmm14     struct{ __xmm_reg [16]int8 }
	__fpu_xmm15     struct{ __xmm_reg [16]int8 }
	__fpu_rsrv4     [96]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh8     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh9     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh10    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh11    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh12    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh13    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh14    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh15    struct{ __xmm_reg [16]int8 }
} /* _structs.h:847:1 */

type __darwin_x86_avx512_state64 = struct {
	__fpu_reserved [2]int32
	__fpu_fcw      struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	__fpu_fsw struct {
		_         [0]uint16
		__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm1 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm2 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm3 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm4 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm5 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm6 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_stmm7 struct {
		__mmst_reg  [10]int8
		__mmst_rsrv [6]int8
	}
	__fpu_xmm0      struct{ __xmm_reg [16]int8 }
	__fpu_xmm1      struct{ __xmm_reg [16]int8 }
	__fpu_xmm2      struct{ __xmm_reg [16]int8 }
	__fpu_xmm3      struct{ __xmm_reg [16]int8 }
	__fpu_xmm4      struct{ __xmm_reg [16]int8 }
	__fpu_xmm5      struct{ __xmm_reg [16]int8 }
	__fpu_xmm6      struct{ __xmm_reg [16]int8 }
	__fpu_xmm7      struct{ __xmm_reg [16]int8 }
	__fpu_xmm8      struct{ __xmm_reg [16]int8 }
	__fpu_xmm9      struct{ __xmm_reg [16]int8 }
	__fpu_xmm10     struct{ __xmm_reg [16]int8 }
	__fpu_xmm11     struct{ __xmm_reg [16]int8 }
	__fpu_xmm12     struct{ __xmm_reg [16]int8 }
	__fpu_xmm13     struct{ __xmm_reg [16]int8 }
	__fpu_xmm14     struct{ __xmm_reg [16]int8 }
	__fpu_xmm15     struct{ __xmm_reg [16]int8 }
	__fpu_rsrv4     [96]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh8     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh9     struct{ __xmm_reg [16]int8 }
	__fpu_ymmh10    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh11    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh12    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh13    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh14    struct{ __xmm_reg [16]int8 }
	__fpu_ymmh15    struct{ __xmm_reg [16]int8 }
	__fpu_k0        struct{ __opmask_reg [8]int8 }
	__fpu_k1        struct{ __opmask_reg [8]int8 }
	__fpu_k2        struct{ __opmask_reg [8]int8 }
	__fpu_k3        struct{ __opmask_reg [8]int8 }
	__fpu_k4        struct{ __opmask_reg [8]int8 }
	__fpu_k5        struct{ __opmask_reg [8]int8 }
	__fpu_k6        struct{ __opmask_reg [8]int8 }
	__fpu_k7        struct{ __opmask_reg [8]int8 }
	__fpu_zmmh0     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh1     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh2     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh3     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh4     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh5     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh6     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh7     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh8     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh9     struct{ __ymm_reg [32]int8 }
	__fpu_zmmh10    struct{ __ymm_reg [32]int8 }
	__fpu_zmmh11    struct{ __ymm_reg [32]int8 }
	__fpu_zmmh12    struct{ __ymm_reg [32]int8 }
	__fpu_zmmh13    struct{ __ymm_reg [32]int8 }
	__fpu_zmmh14    struct{ __ymm_reg [32]int8 }
	__fpu_zmmh15    struct{ __ymm_reg [32]int8 }
	__fpu_zmm16     struct{ __zmm_reg [64]int8 }
	__fpu_zmm17     struct{ __zmm_reg [64]int8 }
	__fpu_zmm18     struct{ __zmm_reg [64]int8 }
	__fpu_zmm19     struct{ __zmm_reg [64]int8 }
	__fpu_zmm20     struct{ __zmm_reg [64]int8 }
	__fpu_zmm21     struct{ __zmm_reg [64]int8 }
	__fpu_zmm22     struct{ __zmm_reg [64]int8 }
	__fpu_zmm23     struct{ __zmm_reg [64]int8 }
	__fpu_zmm24     struct{ __zmm_reg [64]int8 }
	__fpu_zmm25     struct{ __zmm_reg [64]int8 }
	__fpu_zmm26     struct{ __zmm_reg [64]int8 }
	__fpu_zmm27     struct{ __zmm_reg [64]int8 }
	__fpu_zmm28     struct{ __zmm_reg [64]int8 }
	__fpu_zmm29     struct{ __zmm_reg [64]int8 }
	__fpu_zmm30     struct{ __zmm_reg [64]int8 }
	__fpu_zmm31     struct{ __zmm_reg [64]int8 }
} /* _structs.h:915:1 */

type __darwin_x86_exception_state64 = struct {
	__trapno     uint16
	__cpu        uint16
	__err        uint32
	__faultvaddr uint64
} /* _structs.h:1254:1 */

type __darwin_x86_debug_state64 = struct {
	__dr0 uint64
	__dr1 uint64
	__dr2 uint64
	__dr3 uint64
	__dr4 uint64
	__dr5 uint64
	__dr6 uint64
	__dr7 uint64
} /* _structs.h:1274:1 */

type __darwin_x86_cpmu_state64 = struct{ __ctrs [16]uint64 } /* _structs.h:1302:1 */

type __darwin_mcontext32 = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint32
	}
	__ss struct {
		__eax    uint32
		__ebx    uint32
		__ecx    uint32
		__edx    uint32
		__edi    uint32
		__esi    uint32
		__ebp    uint32
		__esp    uint32
		__ss     uint32
		__eflags uint32
		__eip    uint32
		__cs     uint32
		__ds     uint32
		__es     uint32
		__fs     uint32
		__gs     uint32
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [224]int8
		__fpu_reserved1 int32
	}
} /* _mcontext.h:41:1 */

type __darwin_mcontext_avx32 = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint32
	}
	__ss struct {
		__eax    uint32
		__ebx    uint32
		__ecx    uint32
		__edx    uint32
		__edi    uint32
		__esi    uint32
		__ebp    uint32
		__esp    uint32
		__ss     uint32
		__eflags uint32
		__eip    uint32
		__cs     uint32
		__ds     uint32
		__es     uint32
		__fs     uint32
		__gs     uint32
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [224]int8
		__fpu_reserved1 int32
		__avx_reserved1 [64]int8
		__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
	}
} /* _mcontext.h:49:1 */

type __darwin_mcontext_avx512_32 = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint32
	}
	__ss struct {
		__eax    uint32
		__ebx    uint32
		__ecx    uint32
		__edx    uint32
		__edi    uint32
		__esi    uint32
		__ebp    uint32
		__esp    uint32
		__ss     uint32
		__eflags uint32
		__eip    uint32
		__cs     uint32
		__ds     uint32
		__es     uint32
		__fs     uint32
		__gs     uint32
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [224]int8
		__fpu_reserved1 int32
		__avx_reserved1 [64]int8
		__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
		__fpu_k0        struct{ __opmask_reg [8]int8 }
		__fpu_k1        struct{ __opmask_reg [8]int8 }
		__fpu_k2        struct{ __opmask_reg [8]int8 }
		__fpu_k3        struct{ __opmask_reg [8]int8 }
		__fpu_k4        struct{ __opmask_reg [8]int8 }
		__fpu_k5        struct{ __opmask_reg [8]int8 }
		__fpu_k6        struct{ __opmask_reg [8]int8 }
		__fpu_k7        struct{ __opmask_reg [8]int8 }
		__fpu_zmmh0     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh1     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh2     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh3     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh4     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh5     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh6     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh7     struct{ __ymm_reg [32]int8 }
	}
} /* _mcontext.h:58:1 */

type __darwin_mcontext64 = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint64
	}
	__ss struct {
		__rax    uint64
		__rbx    uint64
		__rcx    uint64
		__rdx    uint64
		__rdi    uint64
		__rsi    uint64
		__rbp    uint64
		__rsp    uint64
		__r8     uint64
		__r9     uint64
		__r10    uint64
		__r11    uint64
		__r12    uint64
		__r13    uint64
		__r14    uint64
		__r15    uint64
		__rip    uint64
		__rflags uint64
		__cs     uint64
		__fs     uint64
		__gs     uint64
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_xmm8      struct{ __xmm_reg [16]int8 }
		__fpu_xmm9      struct{ __xmm_reg [16]int8 }
		__fpu_xmm10     struct{ __xmm_reg [16]int8 }
		__fpu_xmm11     struct{ __xmm_reg [16]int8 }
		__fpu_xmm12     struct{ __xmm_reg [16]int8 }
		__fpu_xmm13     struct{ __xmm_reg [16]int8 }
		__fpu_xmm14     struct{ __xmm_reg [16]int8 }
		__fpu_xmm15     struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [96]int8
		__fpu_reserved1 int32
	}
	_ [4]byte
} /* _mcontext.h:99:1 */

type __darwin_mcontext64_full = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint64
	}
	__ss struct {
		__ss64 struct {
			__rax    uint64
			__rbx    uint64
			__rcx    uint64
			__rdx    uint64
			__rdi    uint64
			__rsi    uint64
			__rbp    uint64
			__rsp    uint64
			__r8     uint64
			__r9     uint64
			__r10    uint64
			__r11    uint64
			__r12    uint64
			__r13    uint64
			__r14    uint64
			__r15    uint64
			__rip    uint64
			__rflags uint64
			__cs     uint64
			__fs     uint64
			__gs     uint64
		}
		__ds     uint64
		__es     uint64
		__ss     uint64
		__gsbase uint64
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_xmm8      struct{ __xmm_reg [16]int8 }
		__fpu_xmm9      struct{ __xmm_reg [16]int8 }
		__fpu_xmm10     struct{ __xmm_reg [16]int8 }
		__fpu_xmm11     struct{ __xmm_reg [16]int8 }
		__fpu_xmm12     struct{ __xmm_reg [16]int8 }
		__fpu_xmm13     struct{ __xmm_reg [16]int8 }
		__fpu_xmm14     struct{ __xmm_reg [16]int8 }
		__fpu_xmm15     struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [96]int8
		__fpu_reserved1 int32
	}
	_ [4]byte
} /* _mcontext.h:107:1 */

type __darwin_mcontext_avx64 = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint64
	}
	__ss struct {
		__rax    uint64
		__rbx    uint64
		__rcx    uint64
		__rdx    uint64
		__rdi    uint64
		__rsi    uint64
		__rbp    uint64
		__rsp    uint64
		__r8     uint64
		__r9     uint64
		__r10    uint64
		__r11    uint64
		__r12    uint64
		__r13    uint64
		__r14    uint64
		__r15    uint64
		__rip    uint64
		__rflags uint64
		__cs     uint64
		__fs     uint64
		__gs     uint64
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_xmm8      struct{ __xmm_reg [16]int8 }
		__fpu_xmm9      struct{ __xmm_reg [16]int8 }
		__fpu_xmm10     struct{ __xmm_reg [16]int8 }
		__fpu_xmm11     struct{ __xmm_reg [16]int8 }
		__fpu_xmm12     struct{ __xmm_reg [16]int8 }
		__fpu_xmm13     struct{ __xmm_reg [16]int8 }
		__fpu_xmm14     struct{ __xmm_reg [16]int8 }
		__fpu_xmm15     struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [96]int8
		__fpu_reserved1 int32
		__avx_reserved1 [64]int8
		__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh8     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh9     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh10    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh11    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh12    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh13    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh14    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh15    struct{ __xmm_reg [16]int8 }
	}
	_ [4]byte
} /* _mcontext.h:115:1 */

type __darwin_mcontext_avx64_full = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint64
	}
	__ss struct {
		__ss64 struct {
			__rax    uint64
			__rbx    uint64
			__rcx    uint64
			__rdx    uint64
			__rdi    uint64
			__rsi    uint64
			__rbp    uint64
			__rsp    uint64
			__r8     uint64
			__r9     uint64
			__r10    uint64
			__r11    uint64
			__r12    uint64
			__r13    uint64
			__r14    uint64
			__r15    uint64
			__rip    uint64
			__rflags uint64
			__cs     uint64
			__fs     uint64
			__gs     uint64
		}
		__ds     uint64
		__es     uint64
		__ss     uint64
		__gsbase uint64
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_xmm8      struct{ __xmm_reg [16]int8 }
		__fpu_xmm9      struct{ __xmm_reg [16]int8 }
		__fpu_xmm10     struct{ __xmm_reg [16]int8 }
		__fpu_xmm11     struct{ __xmm_reg [16]int8 }
		__fpu_xmm12     struct{ __xmm_reg [16]int8 }
		__fpu_xmm13     struct{ __xmm_reg [16]int8 }
		__fpu_xmm14     struct{ __xmm_reg [16]int8 }
		__fpu_xmm15     struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [96]int8
		__fpu_reserved1 int32
		__avx_reserved1 [64]int8
		__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh8     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh9     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh10    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh11    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh12    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh13    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh14    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh15    struct{ __xmm_reg [16]int8 }
	}
	_ [4]byte
} /* _mcontext.h:123:1 */

type __darwin_mcontext_avx512_64 = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint64
	}
	__ss struct {
		__rax    uint64
		__rbx    uint64
		__rcx    uint64
		__rdx    uint64
		__rdi    uint64
		__rsi    uint64
		__rbp    uint64
		__rsp    uint64
		__r8     uint64
		__r9     uint64
		__r10    uint64
		__r11    uint64
		__r12    uint64
		__r13    uint64
		__r14    uint64
		__r15    uint64
		__rip    uint64
		__rflags uint64
		__cs     uint64
		__fs     uint64
		__gs     uint64
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_xmm8      struct{ __xmm_reg [16]int8 }
		__fpu_xmm9      struct{ __xmm_reg [16]int8 }
		__fpu_xmm10     struct{ __xmm_reg [16]int8 }
		__fpu_xmm11     struct{ __xmm_reg [16]int8 }
		__fpu_xmm12     struct{ __xmm_reg [16]int8 }
		__fpu_xmm13     struct{ __xmm_reg [16]int8 }
		__fpu_xmm14     struct{ __xmm_reg [16]int8 }
		__fpu_xmm15     struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [96]int8
		__fpu_reserved1 int32
		__avx_reserved1 [64]int8
		__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh8     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh9     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh10    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh11    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh12    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh13    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh14    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh15    struct{ __xmm_reg [16]int8 }
		__fpu_k0        struct{ __opmask_reg [8]int8 }
		__fpu_k1        struct{ __opmask_reg [8]int8 }
		__fpu_k2        struct{ __opmask_reg [8]int8 }
		__fpu_k3        struct{ __opmask_reg [8]int8 }
		__fpu_k4        struct{ __opmask_reg [8]int8 }
		__fpu_k5        struct{ __opmask_reg [8]int8 }
		__fpu_k6        struct{ __opmask_reg [8]int8 }
		__fpu_k7        struct{ __opmask_reg [8]int8 }
		__fpu_zmmh0     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh1     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh2     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh3     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh4     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh5     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh6     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh7     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh8     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh9     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh10    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh11    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh12    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh13    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh14    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh15    struct{ __ymm_reg [32]int8 }
		__fpu_zmm16     struct{ __zmm_reg [64]int8 }
		__fpu_zmm17     struct{ __zmm_reg [64]int8 }
		__fpu_zmm18     struct{ __zmm_reg [64]int8 }
		__fpu_zmm19     struct{ __zmm_reg [64]int8 }
		__fpu_zmm20     struct{ __zmm_reg [64]int8 }
		__fpu_zmm21     struct{ __zmm_reg [64]int8 }
		__fpu_zmm22     struct{ __zmm_reg [64]int8 }
		__fpu_zmm23     struct{ __zmm_reg [64]int8 }
		__fpu_zmm24     struct{ __zmm_reg [64]int8 }
		__fpu_zmm25     struct{ __zmm_reg [64]int8 }
		__fpu_zmm26     struct{ __zmm_reg [64]int8 }
		__fpu_zmm27     struct{ __zmm_reg [64]int8 }
		__fpu_zmm28     struct{ __zmm_reg [64]int8 }
		__fpu_zmm29     struct{ __zmm_reg [64]int8 }
		__fpu_zmm30     struct{ __zmm_reg [64]int8 }
		__fpu_zmm31     struct{ __zmm_reg [64]int8 }
	}
	_ [4]byte
} /* _mcontext.h:132:1 */

type __darwin_mcontext_avx512_64_full = struct {
	__es struct {
		__trapno     uint16
		__cpu        uint16
		__err        uint32
		__faultvaddr uint64
	}
	__ss struct {
		__ss64 struct {
			__rax    uint64
			__rbx    uint64
			__rcx    uint64
			__rdx    uint64
			__rdi    uint64
			__rsi    uint64
			__rbp    uint64
			__rsp    uint64
			__r8     uint64
			__r9     uint64
			__r10    uint64
			__r11    uint64
			__r12    uint64
			__r13    uint64
			__r14    uint64
			__r15    uint64
			__rip    uint64
			__rflags uint64
			__cs     uint64
			__fs     uint64
			__gs     uint64
		}
		__ds     uint64
		__es     uint64
		__ss     uint64
		__gsbase uint64
	}
	__fs struct {
		__fpu_reserved [2]int32
		__fpu_fcw      struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		__fpu_fsw struct {
			_         [0]uint16
			__invalid uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		__fpu_ftw       uint8
		__fpu_rsrv1     uint8
		__fpu_fop       uint16
		__fpu_ip        uint32
		__fpu_cs        uint16
		__fpu_rsrv2     uint16
		__fpu_dp        uint32
		__fpu_ds        uint16
		__fpu_rsrv3     uint16
		__fpu_mxcsr     uint32
		__fpu_mxcsrmask uint32
		__fpu_stmm0     struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm1 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm2 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm3 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm4 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm5 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm6 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_stmm7 struct {
			__mmst_reg  [10]int8
			__mmst_rsrv [6]int8
		}
		__fpu_xmm0      struct{ __xmm_reg [16]int8 }
		__fpu_xmm1      struct{ __xmm_reg [16]int8 }
		__fpu_xmm2      struct{ __xmm_reg [16]int8 }
		__fpu_xmm3      struct{ __xmm_reg [16]int8 }
		__fpu_xmm4      struct{ __xmm_reg [16]int8 }
		__fpu_xmm5      struct{ __xmm_reg [16]int8 }
		__fpu_xmm6      struct{ __xmm_reg [16]int8 }
		__fpu_xmm7      struct{ __xmm_reg [16]int8 }
		__fpu_xmm8      struct{ __xmm_reg [16]int8 }
		__fpu_xmm9      struct{ __xmm_reg [16]int8 }
		__fpu_xmm10     struct{ __xmm_reg [16]int8 }
		__fpu_xmm11     struct{ __xmm_reg [16]int8 }
		__fpu_xmm12     struct{ __xmm_reg [16]int8 }
		__fpu_xmm13     struct{ __xmm_reg [16]int8 }
		__fpu_xmm14     struct{ __xmm_reg [16]int8 }
		__fpu_xmm15     struct{ __xmm_reg [16]int8 }
		__fpu_rsrv4     [96]int8
		__fpu_reserved1 int32
		__avx_reserved1 [64]int8
		__fpu_ymmh0     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh1     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh2     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh3     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh4     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh5     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh6     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh7     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh8     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh9     struct{ __xmm_reg [16]int8 }
		__fpu_ymmh10    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh11    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh12    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh13    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh14    struct{ __xmm_reg [16]int8 }
		__fpu_ymmh15    struct{ __xmm_reg [16]int8 }
		__fpu_k0        struct{ __opmask_reg [8]int8 }
		__fpu_k1        struct{ __opmask_reg [8]int8 }
		__fpu_k2        struct{ __opmask_reg [8]int8 }
		__fpu_k3        struct{ __opmask_reg [8]int8 }
		__fpu_k4        struct{ __opmask_reg [8]int8 }
		__fpu_k5        struct{ __opmask_reg [8]int8 }
		__fpu_k6        struct{ __opmask_reg [8]int8 }
		__fpu_k7        struct{ __opmask_reg [8]int8 }
		__fpu_zmmh0     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh1     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh2     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh3     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh4     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh5     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh6     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh7     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh8     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh9     struct{ __ymm_reg [32]int8 }
		__fpu_zmmh10    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh11    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh12    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh13    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh14    struct{ __ymm_reg [32]int8 }
		__fpu_zmmh15    struct{ __ymm_reg [32]int8 }
		__fpu_zmm16     struct{ __zmm_reg [64]int8 }
		__fpu_zmm17     struct{ __zmm_reg [64]int8 }
		__fpu_zmm18     struct{ __zmm_reg [64]int8 }
		__fpu_zmm19     struct{ __zmm_reg [64]int8 }
		__fpu_zmm20     struct{ __zmm_reg [64]int8 }
		__fpu_zmm21     struct{ __zmm_reg [64]int8 }
		__fpu_zmm22     struct{ __zmm_reg [64]int8 }
		__fpu_zmm23     struct{ __zmm_reg [64]int8 }
		__fpu_zmm24     struct{ __zmm_reg [64]int8 }
		__fpu_zmm25     struct{ __zmm_reg [64]int8 }
		__fpu_zmm26     struct{ __zmm_reg [64]int8 }
		__fpu_zmm27     struct{ __zmm_reg [64]int8 }
		__fpu_zmm28     struct{ __zmm_reg [64]int8 }
		__fpu_zmm29     struct{ __zmm_reg [64]int8 }
		__fpu_zmm30     struct{ __zmm_reg [64]int8 }
		__fpu_zmm31     struct{ __zmm_reg [64]int8 }
	}
	_ [4]byte
} /* _mcontext.h:140:1 */

type mcontext_t = uintptr /* _mcontext.h:206:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type pthread_attr_t = _opaque_pthread_attr_t /* _pthread_attr_t.h:31:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type __darwin_sigaltstack = struct {
	ss_sp    uintptr
	ss_size  uint64
	ss_flags int32
	_        [4]byte
} /* _sigaltstack.h:42:1 */

type stack_t = __darwin_sigaltstack /* _sigaltstack.h:48:33 */ // [???] signal stack

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

type __darwin_ucontext = struct {
	uc_onstack int32
	uc_sigmask uint32
	uc_stack   struct {
		ss_sp    uintptr
		ss_size  uint64
		ss_flags int32
		_        [4]byte
	}
	uc_link     uintptr
	uc_mcsize   uint64
	uc_mcontext uintptr
} /* _ucontext.h:43:1 */

// user context
type ucontext_t = __darwin_ucontext /* _ucontext.h:57:33 */ // [???] user context

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type sigset_t = uint32 /* _sigset_t.h:31:41 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type uid_t = uint32 /* _uid_t.h:31:31 */

type sigval = struct {
	_         [0]uint64
	sival_int int32
	_         [4]byte
} /* signal.h:158:1 */

type sigevent = struct {
	sigev_notify int32
	sigev_signo  int32
	sigev_value  struct {
		_         [0]uint64
		sival_int int32
		_         [4]byte
	}
	sigev_notify_function   uintptr
	sigev_notify_attributes uintptr
} /* signal.h:168:1 */

type __siginfo = struct {
	si_signo  int32
	si_errno  int32
	si_code   int32
	si_pid    pid_t
	si_uid    uid_t
	si_status int32
	si_addr   uintptr
	si_value  struct {
		_         [0]uint64
		sival_int int32
		_         [4]byte
	}
	si_band int64
	__pad   [7]uint64
} /* signal.h:177:9 */

type siginfo_t = __siginfo /* signal.h:188:3 */

// When the signal is SIGILL or SIGFPE, si_addr contains the address of
// the faulting instruction.
// When the signal is SIGSEGV or SIGBUS, si_addr contains the address of
// the faulting memory reference. Although for x86 there are cases of SIGSEGV
// for which si_addr cannot be determined and is NULL.
// If the signal is SIGCHLD, the si_pid field will contain the child process ID,
//  si_status contains the exit value or signal and
//  si_uid contains the real user ID of the process that sent the signal.

// Values for si_code

// Codes for SIGILL

// Codes for SIGFPE

// Codes for SIGSEGV

// Codes for SIGBUS

// Codes for SIGTRAP

// Codes for SIGCHLD

// Codes for SIGPOLL

// union for signal handlers
type __sigaction_u = struct{ __sa_handler uintptr } /* signal.h:269:1 */

// Signal vector template for Kernel user boundary
type __sigaction = struct {
	__sigaction_u struct{ __sa_handler uintptr }
	sa_tramp      uintptr
	sa_mask       sigset_t
	sa_flags      int32
} /* signal.h:276:1 */

// Signal vector "template" used in sigaction call.
type sigaction = struct {
	__sigaction_u struct{ __sa_handler uintptr }
	sa_mask       sigset_t
	sa_flags      int32
} /* signal.h:286:1 */

// if SA_SIGINFO is set, sa_sigaction is to be used instead of sa_handler.

// This will provide 64bit register set in a 32bit user address space

// the following are the only bits we support from user space, the
// rest are for kernel use only.

// Flags for sigprocmask:

// POSIX 1003.1b required values.

type sig_t = uintptr /* signal.h:331:14 */ // type of signal function

// Structure used in sigaltstack call.

// 4.3 compatibility:
// Signal vector "template" used in sigvec call.
type sigvec = struct {
	sv_handler uintptr
	sv_mask    int32
	sv_flags   int32
} /* signal.h:348:1 */

// Structure used in sigstack call.
type sigstack = struct {
	ss_sp      uintptr
	ss_onstack int32
	_          [4]byte
} /* signal.h:367:1 */

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)resource.h	8.2 (Berkeley) 1/4/94

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

//===---- stdint.h - Standard header for sized integer types --------------===* *
//  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://llvm.org/LICENSE.txt for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// \*===----------------------------------------------------------------------===

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// [XSI] The timeval structure shall be defined as described in
// <sys/time.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type timeval = struct {
	tv_sec  int64
	tv_usec int32
	_       [4]byte
} /* _timeval.h:34:1 */

// The id_t type shall be defined as described in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Resource limit type (low 63 bits, excluding the sign bit)
type rlim_t = uint64 /* resource.h:89:25 */

// ****
//
// PRIORITY

// Possible values of the first parameter to getpriority()/setpriority(),
// used to indicate the type of the second parameter.

// Range limitations for the value of the third parameter to setpriority().

// use PRIO_DARWIN_BG to set the current thread into "background" state
// which lowers CPU, disk IO, and networking priorites until thread terminates
// or "background" state is revoked

// use PRIO_DARWIN_NONUI to restrict a process's ability to make calls to
// the GPU. (deprecated)

// ****
//
// RESOURCE USAGE

// Possible values of the first parameter to getrusage(), used to indicate
// the scope of the information to be returned.

// A structure representing an accounting of resource utilization.  The
// address of an instance of this structure is the second parameter to
// getrusage().
//
// Note: All values other than ru_utime and ru_stime are implementaiton
//       defined and subject to change in a future release.  Their use
//       is discouraged for standards compliant programs.
type rusage = struct {
	ru_utime struct {
		tv_sec  int64
		tv_usec int32
		_       [4]byte
	}
	ru_stime struct {
		tv_sec  int64
		tv_usec int32
		_       [4]byte
	}
	ru_maxrss   int64
	ru_ixrss    int64
	ru_idrss    int64
	ru_isrss    int64
	ru_minflt   int64
	ru_majflt   int64
	ru_nswap    int64
	ru_inblock  int64
	ru_oublock  int64
	ru_msgsnd   int64
	ru_msgrcv   int64
	ru_nsignals int64
	ru_nvcsw    int64
	ru_nivcsw   int64
} /* resource.h:152:1 */

// Flavors for proc_pid_rusage().

// Flags for RUSAGE_INFO_V5

type rusage_info_t = uintptr /* resource.h:199:14 */

type rusage_info_v0 = struct {
	ri_uuid               [16]uint8_t
	ri_user_time          uint64_t
	ri_system_time        uint64_t
	ri_pkg_idle_wkups     uint64_t
	ri_interrupt_wkups    uint64_t
	ri_pageins            uint64_t
	ri_wired_size         uint64_t
	ri_resident_size      uint64_t
	ri_phys_footprint     uint64_t
	ri_proc_start_abstime uint64_t
	ri_proc_exit_abstime  uint64_t
} /* resource.h:201:1 */

type rusage_info_v1 = struct {
	ri_uuid                  [16]uint8_t
	ri_user_time             uint64_t
	ri_system_time           uint64_t
	ri_pkg_idle_wkups        uint64_t
	ri_interrupt_wkups       uint64_t
	ri_pageins               uint64_t
	ri_wired_size            uint64_t
	ri_resident_size         uint64_t
	ri_phys_footprint        uint64_t
	ri_proc_start_abstime    uint64_t
	ri_proc_exit_abstime     uint64_t
	ri_child_user_time       uint64_t
	ri_child_system_time     uint64_t
	ri_child_pkg_idle_wkups  uint64_t
	ri_child_interrupt_wkups uint64_t
	ri_child_pageins         uint64_t
	ri_child_elapsed_abstime uint64_t
} /* resource.h:215:1 */

type rusage_info_v2 = struct {
	ri_uuid                  [16]uint8_t
	ri_user_time             uint64_t
	ri_system_time           uint64_t
	ri_pkg_idle_wkups        uint64_t
	ri_interrupt_wkups       uint64_t
	ri_pageins               uint64_t
	ri_wired_size            uint64_t
	ri_resident_size         uint64_t
	ri_phys_footprint        uint64_t
	ri_proc_start_abstime    uint64_t
	ri_proc_exit_abstime     uint64_t
	ri_child_user_time       uint64_t
	ri_child_system_time     uint64_t
	ri_child_pkg_idle_wkups  uint64_t
	ri_child_interrupt_wkups uint64_t
	ri_child_pageins         uint64_t
	ri_child_elapsed_abstime uint64_t
	ri_diskio_bytesread      uint64_t
	ri_diskio_byteswritten   uint64_t
} /* resource.h:235:1 */

type rusage_info_v3 = struct {
	ri_uuid                          [16]uint8_t
	ri_user_time                     uint64_t
	ri_system_time                   uint64_t
	ri_pkg_idle_wkups                uint64_t
	ri_interrupt_wkups               uint64_t
	ri_pageins                       uint64_t
	ri_wired_size                    uint64_t
	ri_resident_size                 uint64_t
	ri_phys_footprint                uint64_t
	ri_proc_start_abstime            uint64_t
	ri_proc_exit_abstime             uint64_t
	ri_child_user_time               uint64_t
	ri_child_system_time             uint64_t
	ri_child_pkg_idle_wkups          uint64_t
	ri_child_interrupt_wkups         uint64_t
	ri_child_pageins                 uint64_t
	ri_child_elapsed_abstime         uint64_t
	ri_diskio_bytesread              uint64_t
	ri_diskio_byteswritten           uint64_t
	ri_cpu_time_qos_default          uint64_t
	ri_cpu_time_qos_maintenance      uint64_t
	ri_cpu_time_qos_background       uint64_t
	ri_cpu_time_qos_utility          uint64_t
	ri_cpu_time_qos_legacy           uint64_t
	ri_cpu_time_qos_user_initiated   uint64_t
	ri_cpu_time_qos_user_interactive uint64_t
	ri_billed_system_time            uint64_t
	ri_serviced_system_time          uint64_t
} /* resource.h:257:1 */

type rusage_info_v4 = struct {
	ri_uuid                          [16]uint8_t
	ri_user_time                     uint64_t
	ri_system_time                   uint64_t
	ri_pkg_idle_wkups                uint64_t
	ri_interrupt_wkups               uint64_t
	ri_pageins                       uint64_t
	ri_wired_size                    uint64_t
	ri_resident_size                 uint64_t
	ri_phys_footprint                uint64_t
	ri_proc_start_abstime            uint64_t
	ri_proc_exit_abstime             uint64_t
	ri_child_user_time               uint64_t
	ri_child_system_time             uint64_t
	ri_child_pkg_idle_wkups          uint64_t
	ri_child_interrupt_wkups         uint64_t
	ri_child_pageins                 uint64_t
	ri_child_elapsed_abstime         uint64_t
	ri_diskio_bytesread              uint64_t
	ri_diskio_byteswritten           uint64_t
	ri_cpu_time_qos_default          uint64_t
	ri_cpu_time_qos_maintenance      uint64_t
	ri_cpu_time_qos_background       uint64_t
	ri_cpu_time_qos_utility          uint64_t
	ri_cpu_time_qos_legacy           uint64_t
	ri_cpu_time_qos_user_initiated   uint64_t
	ri_cpu_time_qos_user_interactive uint64_t
	ri_billed_system_time            uint64_t
	ri_serviced_system_time          uint64_t
	ri_logical_writes                uint64_t
	ri_lifetime_max_phys_footprint   uint64_t
	ri_instructions                  uint64_t
	ri_cycles                        uint64_t
	ri_billed_energy                 uint64_t
	ri_serviced_energy               uint64_t
	ri_interval_max_phys_footprint   uint64_t
	ri_runnable_time                 uint64_t
} /* resource.h:288:1 */

type rusage_info_v5 = struct {
	ri_uuid                          [16]uint8_t
	ri_user_time                     uint64_t
	ri_system_time                   uint64_t
	ri_pkg_idle_wkups                uint64_t
	ri_interrupt_wkups               uint64_t
	ri_pageins                       uint64_t
	ri_wired_size                    uint64_t
	ri_resident_size                 uint64_t
	ri_phys_footprint                uint64_t
	ri_proc_start_abstime            uint64_t
	ri_proc_exit_abstime             uint64_t
	ri_child_user_time               uint64_t
	ri_child_system_time             uint64_t
	ri_child_pkg_idle_wkups          uint64_t
	ri_child_interrupt_wkups         uint64_t
	ri_child_pageins                 uint64_t
	ri_child_elapsed_abstime         uint64_t
	ri_diskio_bytesread              uint64_t
	ri_diskio_byteswritten           uint64_t
	ri_cpu_time_qos_default          uint64_t
	ri_cpu_time_qos_maintenance      uint64_t
	ri_cpu_time_qos_background       uint64_t
	ri_cpu_time_qos_utility          uint64_t
	ri_cpu_time_qos_legacy           uint64_t
	ri_cpu_time_qos_user_initiated   uint64_t
	ri_cpu_time_qos_user_interactive uint64_t
	ri_billed_system_time            uint64_t
	ri_serviced_system_time          uint64_t
	ri_logical_writes                uint64_t
	ri_lifetime_max_phys_footprint   uint64_t
	ri_instructions                  uint64_t
	ri_cycles                        uint64_t
	ri_billed_energy                 uint64_t
	ri_serviced_energy               uint64_t
	ri_interval_max_phys_footprint   uint64_t
	ri_runnable_time                 uint64_t
	ri_flags                         uint64_t
} /* resource.h:327:1 */

type rusage_info_current = rusage_info_v5 /* resource.h:367:31 */

// ****
//
// RESOURCE LIMITS

// Symbolic constants for resource limits; since all limits are representable
// as a type rlim_t, we are permitted to define RLIM_SAVED_* in terms of
// RLIM_INFINITY.

// Possible values of the first parameter to getrlimit()/setrlimit(), to
// indicate for which resource the operation is being performed.

// A structure representing a resource limit.  The address of an instance
// of this structure is the second parameter to getrlimit()/setrlimit().
type rlimit = struct {
	rlim_cur rlim_t
	rlim_max rlim_t
} /* resource.h:411:1 */

// proc_rlimit_control()
//
// Resource limit flavors

// Flags for wakeups monitor control.

// Flags for CPU usage monitor control.

// Flags for memory footprint interval tracking.

type proc_rlimit_control_wakeupmon = struct {
	wm_flags uint32_t
	wm_rate  int32_t
} /* resource.h:446:1 */

// Deprecated:
// Structure of the information in the status word returned by wait4.
// If w_stopval==_WSTOPPED, then the second structure describes
// the information returned, else the first.
type wait = struct{ w_status int32 } /* wait.h:194:1 */

// built-in for gcc

// built-in for gcc 3

// DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
// _GCC_SIZE_T
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type ct_rune_t = int32 /* _ct_rune_t.h:32:28 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type rune_t = int32 /* _rune_t.h:31:25 */

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// wchar_t is a built-in type in C++

type div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:86:3 */

type ldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:91:3 */

type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:97:3 */

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type dev_t = int32 /* _dev_t.h:31:31 */ // device number
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type mode_t = uint16 /* _mode_t.h:31:33 */

// C11 Annex K

// Darwin extensions

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type ssize_t = int64 /* _ssize_t.h:31:33 */

// Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93

// Security checking functions.
// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2007, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// bcopy and bzero

// Removed in Issue 7

// void	bcopy(const void *src, void *dst, size_t len)

// void	bzero(void *s, size_t n)

// Security checking functions.
// Copyright (c) 2007,2017 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2007, 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// <rdar://problem/12622659>

// memccpy, memcpy, mempcpy, memmove, memset, strcpy, strlcpy, stpcpy,
//    strncpy, stpncpy, strcat, strlcat, and strncat

// void *memcpy(void *dst, const void *src, size_t n)

// void *memmove(void *dst, const void *src, size_t len)

// void *memset(void *b, int c, size_t len)

// char *strcpy(char *dst, const char *src)

// char *stpcpy(char *dst, const char *src)

// char *stpncpy(char *dst, const char *src, size_t n)

// char *strncpy(char *dst, const char *src, size_t n)

// char *strcat(char *s1, const char *s2)

// char *strncat(char *s1, const char *s2, size_t n)

//  Select between 32/64-bit I/O streams for FSE. Note that the FSE stream
//  size need not match the word size of the machine, but in practice you
//  want to use 64b streams on 64b systems for better performance.

// MARK: - Bit utils

//! @abstract Signed type used to represent bit count.
type fse_bit_count = int32_t /* lzfse_fse.h:54:17 */

//! @abstract Unsigned type used to represent FSE state.
type fse_state = uint16_t /* lzfse_fse.h:57:18 */

// Mask the NBITS lsb of X. 0 <= NBITS < 64
func fse_mask_lsb64(tls *libc.TLS, x uint64_t, nbits fse_bit_count) uint64_t { /* lzfse_fse.h:60:24: */
	return x & mtable12[nbits]
}

var mtable12 = [65]uint64_t{
	0x0000000000000000, 0x0000000000000001, 0x0000000000000003,
	0x0000000000000007, 0x000000000000000f, 0x000000000000001f,
	0x000000000000003f, 0x000000000000007f, 0x00000000000000ff,
	0x00000000000001ff, 0x00000000000003ff, 0x00000000000007ff,
	0x0000000000000fff, 0x0000000000001fff, 0x0000000000003fff,
	0x0000000000007fff, 0x000000000000ffff, 0x000000000001ffff,
	0x000000000003ffff, 0x000000000007ffff, 0x00000000000fffff,
	0x00000000001fffff, 0x00000000003fffff, 0x00000000007fffff,
	0x0000000000ffffff, 0x0000000001ffffff, 0x0000000003ffffff,
	0x0000000007ffffff, 0x000000000fffffff, 0x000000001fffffff,
	0x000000003fffffff, 0x000000007fffffff, 0x00000000ffffffff,
	0x00000001ffffffff, 0x00000003ffffffff, 0x00000007ffffffff,
	0x0000000fffffffff, 0x0000001fffffffff, 0x0000003fffffffff,
	0x0000007fffffffff, 0x000000ffffffffff, 0x000001ffffffffff,
	0x000003ffffffffff, 0x000007ffffffffff, 0x00000fffffffffff,
	0x00001fffffffffff, 0x00003fffffffffff, 0x00007fffffffffff,
	0x0000ffffffffffff, 0x0001ffffffffffff, 0x0003ffffffffffff,
	0x0007ffffffffffff, 0x000fffffffffffff, 0x001fffffffffffff,
	0x003fffffffffffff, 0x007fffffffffffff, 0x00ffffffffffffff,
	0x01ffffffffffffff, 0x03ffffffffffffff, 0x07ffffffffffffff,
	0x0fffffffffffffff, 0x1fffffffffffffff, 0x3fffffffffffffff,
	0x7fffffffffffffff, libc.Uint64(0xffffffffffffffff),
} /* lzfse_fse.h:61:25 */

// Mask the NBITS lsb of X. 0 <= NBITS < 32
func fse_mask_lsb32(tls *libc.TLS, x uint32_t, nbits fse_bit_count) uint32_t { /* lzfse_fse.h:89:24: */
	return x & mtable13[nbits]
}

var mtable13 = [33]uint32_t{
	0x0000000000000000, 0x0000000000000001, 0x0000000000000003,
	0x0000000000000007, 0x000000000000000f, 0x000000000000001f,
	0x000000000000003f, 0x000000000000007f, 0x00000000000000ff,
	0x00000000000001ff, 0x00000000000003ff, 0x00000000000007ff,
	0x0000000000000fff, 0x0000000000001fff, 0x0000000000003fff,
	0x0000000000007fff, 0x000000000000ffff, 0x000000000001ffff,
	0x000000000003ffff, 0x000000000007ffff, 0x00000000000fffff,
	0x00000000001fffff, 0x00000000003fffff, 0x00000000007fffff,
	0x0000000000ffffff, 0x0000000001ffffff, 0x0000000003ffffff,
	0x0000000007ffffff, 0x000000000fffffff, 0x000000001fffffff,
	0x000000003fffffff, 0x000000007fffffff, 0x00000000ffffffff,
} /* lzfse_fse.h:90:25 */

// MARK: - Bit stream

// I/O streams
// The streams can be shared between several FSE encoders/decoders, which is why
// they are not in the state struct

//! @abstract Output stream, 64-bit accum.
type fse_out_stream64 = struct {
	accum       uint64_t
	accum_nbits fse_bit_count
	_           [4]byte
} /* lzfse_fse.h:144:3 */

//! @abstract Output stream, 32-bit accum.
type fse_out_stream32 = struct {
	accum       uint32_t
	accum_nbits fse_bit_count
} /* lzfse_fse.h:150:3 */

//! @abstract Object representing an input stream.
type fse_in_stream64 = struct {
	accum       uint64_t
	accum_nbits fse_bit_count
	_           [4]byte
} /* lzfse_fse.h:156:3 */

//! @abstract Object representing an input stream.
type fse_in_stream32 = struct {
	accum       uint32_t
	accum_nbits fse_bit_count
} /* lzfse_fse.h:162:3 */

//! @abstract Initialize an output stream object.
func fse_out_init64(tls *libc.TLS, s uintptr) { /* lzfse_fse.h:165:17: */
	(*fse_out_stream64)(unsafe.Pointer(s)).accum = uint64(0)
	(*fse_out_stream64)(unsafe.Pointer(s)).accum_nbits = 0
}

// ! @abstract Write full bytes from the accumulator to output buffer, ensuring
// accum_nbits is in [0, 7].
// We assume we can write 8 bytes to the output buffer \c (*pbuf[0..7]) in all
// cases.
// @note *pbuf is incremented by the number of written bytes.
func fse_out_flush64(tls *libc.TLS, s uintptr, pbuf uintptr) { /* lzfse_fse.h:181:17: */
	var nbits fse_bit_count = (**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits & -8 // number of bits written, multiple of 8

	// Write 8 bytes of current accumulator
	libc.X__builtin___memcpy_chk(tls, *(*uintptr)(unsafe.Pointer(pbuf)), s, uint64(8), libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(pbuf)), 0))
	**(**uintptr)(unsafe.Pointer(uintptr(pbuf))) += uintptr(nbits >> 3) // bytes

	// Update state
	libc.AssignShrPtrUint64(s, int(nbits)) // remove nbits
	*(*fse_bit_count)(unsafe.Pointer(s + 8)) -= nbits

	if libc.X__builtin_expect(tls, libc.BoolInt64(!((**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits >= 0 && (**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits <= 7)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__76)), ts, 193, ts+uintptr(56))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits == 64 || (**(**fse_out_stream64)(unsafe.Pointer(&s))).accum>>(**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits == uint64(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__76)), ts, 194, ts+uintptr(99))
	} else {
	}
}

var __func__76 = *(*[16]int8)(unsafe.Pointer(ts + uintptr(157))) /* lzfse_fse.h:181:70 */

// ! @abstract Write the last bytes from the accumulator to output buffer,
// ensuring accum_nbits is in [-7, 0]. Bits are padded with 0 if needed.
// We assume we can write 8 bytes to the output buffer \c (*pbuf[0..7]) in all
// cases.
// @note *pbuf is incremented by the number of written bytes.
func fse_out_finish64(tls *libc.TLS, s uintptr, pbuf uintptr) { /* lzfse_fse.h:223:17: */
	var nbits fse_bit_count = ((**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits + 7) & -8 // number of bits written, multiple of 8

	// Write 8 bytes of current accumulator
	libc.X__builtin___memcpy_chk(tls, *(*uintptr)(unsafe.Pointer(pbuf)), s, uint64(8), libc.X__builtin_object_size(tls, *(*uintptr)(unsafe.Pointer(pbuf)), 0))
	**(**uintptr)(unsafe.Pointer(uintptr(pbuf))) += uintptr(nbits >> 3) // bytes

	// Update state
	(*fse_out_stream64)(unsafe.Pointer(s)).accum = uint64(0) // remove nbits
	*(*fse_bit_count)(unsafe.Pointer(s + 8)) -= nbits

	if libc.X__builtin_expect(tls, libc.BoolInt64(!((**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits >= -7 && (**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits <= 0)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__78)), ts, 235, ts+uintptr(173))
	} else {
	}
}

var __func__78 = *(*[17]int8)(unsafe.Pointer(ts + uintptr(217))) /* lzfse_fse.h:223:71 */

// ! @abstract Accumulate \c n bits \c b to output stream \c s. We \b must have:
// 0 <= b < 2^n, and N + s->accum_nbits <= 64.
// @note The caller must ensure out_flush is called \b before the accumulator
// overflows to more than 64 bits.
func fse_out_push64(tls *libc.TLS, s uintptr, n fse_bit_count, b uint64_t) { /* lzfse_fse.h:262:17: */
	*(*uint64_t)(unsafe.Pointer(s)) |= b << (**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits
	*(*fse_bit_count)(unsafe.Pointer(s + 8)) += n

	if libc.X__builtin_expect(tls, libc.BoolInt64(!((**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits >= 0 && (**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits <= 64)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__80)), ts, 267, ts+uintptr(234))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits == 64 || (**(**fse_out_stream64)(unsafe.Pointer(&s))).accum>>(**(**fse_out_stream64)(unsafe.Pointer(&s))).accum_nbits == uint64(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__80)), ts, 268, ts+uintptr(99))
	} else {
	}
}

var __func__80 = *(*[15]int8)(unsafe.Pointer(ts + uintptr(278))) /* lzfse_fse.h:263:44 */

// ! @abstract   Initialize the fse input stream so that accum holds between 56
//  and 63 bits. We never want to have 64 bits in the stream, because that allows
//  us to avoid a special case in the fse_in_pull function (eliminating an
//  unpredictable branch), while not requiring any additional fse_flush
//  operations. This is why we have the special case for n == 0 (in which case
//  we want to load only 7 bytes instead of 8).
func fse_in_checked_init64(tls *libc.TLS, s uintptr, n fse_bit_count, pbuf uintptr, buf_start uintptr) int32 { /* lzfse_fse.h:300:16: */
	if n != 0 {
		if *(*uintptr)(unsafe.Pointer(pbuf)) < buf_start+uintptr(8) {
			return -1
		} // out of range
		**(**uintptr)(unsafe.Pointer(uintptr(pbuf))) -= uintptr(8)
		libc.X__builtin___memcpy_chk(tls, s, *(*uintptr)(unsafe.Pointer(pbuf)), uint64(8), libc.X__builtin_object_size(tls, s, 0))
		(*fse_in_stream64)(unsafe.Pointer(s)).accum_nbits = n + 64
	} else {
		if *(*uintptr)(unsafe.Pointer(pbuf)) < buf_start+uintptr(7) {
			return -1
		} // out of range
		**(**uintptr)(unsafe.Pointer(uintptr(pbuf))) -= uintptr(7)
		libc.X__builtin___memcpy_chk(tls, s, *(*uintptr)(unsafe.Pointer(pbuf)), uint64(7), libc.X__builtin_object_size(tls, s, 0))
		*(*uint64_t)(unsafe.Pointer(s)) &= uint64(0xffffffffffffff)
		(*fse_in_stream64)(unsafe.Pointer(s)).accum_nbits = n + 56
	}

	if (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits < 56 || (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits >= 64 || (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum>>(**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits != uint64(0) {
		return -1 // the incoming input is wrong (encoder should have zeroed the
		// upper bits)
	}

	return 0 // OK
}

// ! @abstract  Read in new bytes from buffer to ensure that we have a full
// complement of bits in the stream object (again, between 56 and 63 bits).
// checking the new value of \c *pbuf remains >= \c buf_start.
// @return 0 if OK.
// @return -1 on failure.
func fse_in_checked_flush64(tls *libc.TLS, s uintptr, pbuf uintptr, buf_start uintptr) int32 { /* lzfse_fse.h:361:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	//  Get number of bits to add to bring us into the desired range.
	var nbits fse_bit_count = (63 - (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits) & -8
	//  Convert bits to bytes and decrement buffer address, then load new data.
	var buf uintptr = *(*uintptr)(unsafe.Pointer(pbuf)) - uintptr(nbits>>3)
	if buf < buf_start {
		return -1 // out of range
	}
	*(*uintptr)(unsafe.Pointer(pbuf)) = buf
	// var incoming uint64_t at bp, 8

	libc.X__builtin___memcpy_chk(tls, bp, buf, uint64(8), libc.X__builtin_object_size(tls, bp, 0))
	// Update the state object and verify its validity (in DEBUG).
	(*fse_in_stream64)(unsafe.Pointer(s)).accum = (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum<<nbits | fse_mask_lsb64(tls, uint64_t(**(**uint64_t)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))))), nbits)
	*(*fse_bit_count)(unsafe.Pointer(s + 8)) += nbits
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits >= 56 && (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits < 64)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__82)), ts, 376, ts+uintptr(293))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!((**(**fse_in_stream64)(unsafe.Pointer(&s))).accum>>(**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits == uint64(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__82)), ts, 376, ts+uintptr(337))
	} else {
	}
	return 0 // OK
}

var __func__82 = *(*[23]int8)(unsafe.Pointer(ts + uintptr(371))) /* lzfse_fse.h:362:65 */

//! @abstract Pull n bits out of the fse stream object.
func fse_in_pull64(tls *libc.TLS, s uintptr, n fse_bit_count) uint64_t { /* lzfse_fse.h:407:21: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(n >= 0 && n <= (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__84)), ts, 408, ts+uintptr(394))
	} else {
	}
	*(*fse_bit_count)(unsafe.Pointer(s + 8)) -= n
	var result uint64_t = (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum >> (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits
	(*fse_in_stream64)(unsafe.Pointer(s)).accum = fse_mask_lsb64(tls, (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum, (**(**fse_in_stream64)(unsafe.Pointer(&s))).accum_nbits)
	return result
}

var __func__84 = *(*[14]int8)(unsafe.Pointer(ts + uintptr(424))) /* lzfse_fse.h:407:72 */

// MARK: - Encode/Decode

// Map to 32/64-bit implementations and types for I/O

type fse_bits = uint64_t               /* lzfse_fse.h:429:18 */
type fse_out_stream = fse_out_stream64 /* lzfse_fse.h:430:26 */
type fse_in_stream = fse_in_stream64   /* lzfse_fse.h:431:25 */

//! @abstract Entry for one symbol in the encoder table (64b).
type fse_encoder_entry = struct {
	s0     int16_t
	k      int16_t
	delta0 int16_t
	delta1 int16_t
} /* lzfse_fse.h:474:3 */

//! @abstract  Entry for one state in the decoder table (32b).
type fse_decoder_entry = struct {
	k      int8_t
	symbol uint8_t
	delta  int16_t
} /* lzfse_fse.h:481:3 */

//! @abstract  Entry for one state in the value decoder table (64b).
type fse_value_decoder_entry = struct {
	total_bits uint8_t
	value_bits uint8_t
	delta      int16_t
	vbase      int32_t
} /* lzfse_fse.h:489:3 */

// ! @abstract Encode SYMBOL using the encoder table, and update \c *pstate,
//  \c out.
//  @note The caller must ensure we have enough bits available in the output
//  stream accumulator.
func fse_encode(tls *libc.TLS, pstate uintptr, encoder_table uintptr, out uintptr, symbol uint8_t) { /* lzfse_fse.h:495:17: */
	var s int32 = int32(*(*fse_state)(unsafe.Pointer(pstate)))
	var e = *(*fse_encoder_entry)(unsafe.Pointer(encoder_table + uintptr(symbol)*8))
	var s0 int32 = int32(e.s0)
	var k int32 = int32(e.k)
	var delta0 int32 = int32(e.delta0)
	var delta1 int32 = int32(e.delta1)

	// Number of bits to write
	var hi int32 = libc.Bool32(s >= s0)
	var nbits fse_bit_count
	if hi != 0 {
		nbits = k
	} else {
		nbits = k - 1
	}
	var delta fse_state
	if hi != 0 {
		delta = uint16(delta0)
	} else {
		delta = uint16(delta1)
	}

	// Write lower NBITS of state
	var b fse_bits = fse_mask_lsb64(tls, uint64(s), nbits)
	fse_out_push64(tls, out, nbits, b)

	// Update state with remaining bits and delta
	*(*fse_state)(unsafe.Pointer(pstate)) = fse_state(int32(delta) + s>>nbits)
}

// ! @abstract Decode and return symbol using the decoder table, and update
//  \c *pstate, \c in.
//  @note The caller must ensure we have enough bits available in the input
//  stream accumulator.
func fse_decode(tls *libc.TLS, pstate uintptr, decoder_table uintptr, in uintptr) uint8_t { /* lzfse_fse.h:522:20: */
	var e int32_t = *(*int32_t)(unsafe.Pointer(decoder_table + uintptr(*(*fse_state)(unsafe.Pointer(pstate)))*4))

	// Update state from K bits of input + DELTA
	*(*fse_state)(unsafe.Pointer(pstate)) = fse_state(int32(fse_state(e>>16)) + int32(fse_state(fse_in_pull64(tls, in, e&0xff))))

	// Return the symbol for this state
	return uint8_t(fse_extract_bits64(tls, uint64(e), 8, 8)) // symbol
}

// ! @abstract Decode and return value using the decoder table, and update \c
//  *pstate, \c in.
// \c value_decoder_table[nstates]
// @note The caller must ensure we have enough bits available in the input
// stream accumulator.
func fse_value_decode(tls *libc.TLS, pstate uintptr, value_decoder_table uintptr, in uintptr) int32_t { /* lzfse_fse.h:540:1: */
	var entry = *(*fse_value_decoder_entry)(unsafe.Pointer(value_decoder_table + uintptr(*(*fse_state)(unsafe.Pointer(pstate)))*8))
	var state_and_value_bits uint32_t = uint32_t(fse_in_pull64(tls, in, int32(entry.total_bits)))
	*(*fse_state)(unsafe.Pointer(pstate)) = fse_state(uint32_t(entry.delta) + state_and_value_bits>>int32(entry.value_bits))
	return int32_t(uint64_t(entry.vbase) + fse_mask_lsb64(tls, uint64(state_and_value_bits), int32(entry.value_bits)))
}

// MARK: - Tables

// IMPORTANT: To properly decode an FSE encoded stream, both encoder/decoder
// tables shall be initialized with the same parameters, including the
// FREQ[NSYMBOL] array.
//

// ! @abstract Sanity check on frequency table, verify sum of \c freq
//  is <= \c number_of_states.
func fse_check_freq(tls *libc.TLS, freq_table uintptr, table_size size_t, number_of_states size_t) int32 { /* lzfse_fse.h:560:16: */
	var sum_of_freq size_t = uint64(0)
	{
		var i int32 = 0
	__1:
		if !(size_t(i) < table_size) {
			goto __3
		}
		{
			sum_of_freq = sum_of_freq + size_t(*(*uint16_t)(unsafe.Pointer(freq_table + uintptr(i)*2)))

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	if sum_of_freq > number_of_states {
		return -1
	}
	return 0
}

//
// Copyright (c) 2015-2016, Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//
// 1.  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//
// 2.  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer
//     in the documentation and/or other materials provided with the distribution.
//
// 3.  Neither the name of the copyright holder(s) nor the names of any contributors may be used to endorse or promote products derived
//     from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//  Parameters controlling details of the LZ-style match search. These values
//  may be modified to fine tune compression ratio vs. encoding speed, while
//  keeping the compressed format compatible with LZFSE. Note that
//  modifying them will also change the amount of work space required by
//  the encoder. The values here are those used in the compression library
//  on iOS and OS X.

//  Number of bits for hash function to produce. Should be in the range
//  [10, 16]. Larger values reduce the number of false-positive found during
//  the match search, and expand the history table, which may allow additional
//  matches to be found, generally improving the achieved compression ratio.
//  Larger values also increase the workspace size, and make it less likely
//  that the history table will be present in cache, which reduces performance.

//  Number of positions to store for each line in the history table. May
//  be either 4 or 8. Using 8 doubles the size of the history table, which
//  increases the chance of finding matches (thus improving compression ratio),
//  but also increases the workspace size.

//  Match length in bytes to cause immediate emission. Generally speaking,
//  LZFSE maintains multiple candidate matches and waits to decide which match
//  to emit until more information is available. When a match exceeds this
//  threshold, it is emitted immediately. Thus, smaller values may give
//  somewhat better performance, and larger values may give somewhat better
//  compression ratios.

//  When the source buffer is very small, LZFSE doesn't compress as well as
//  some simpler algorithms. To maintain reasonable compression for these
//  cases, we transition to use LZVN instead if the size of the source buffer
//  is below this threshold.

//===---- limits.h - Standard header for integer sizes --------------------===* *
//  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://llvm.org/LICENSE.txt for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// \*===----------------------------------------------------------------------===

// The system's limits.h may, in turn, try to #include_next GCC's limits.h.
//    Avert this #include_next madness.

// System headers include a number of constants from POSIX in <limits.h>.
//    Include it if we're hosted.

// Many system headers try to "help us out" by defining these.  No really, we
//    know how big each datatype is.

// C90/99 5.2.4.2.1

// C99 5.2.4.2.1: Added long long.
//    C++11 18.3.3.2: same contents as the Standard C Library header <limits.h>.
//

// LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad
//    that we don't have something like #pragma poison that could be used to
//    deprecate a macro - the code should just use LLONG_MAX and friends.
//

// ===---- stddef.h - Basic type definitions --------------------------------===
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===-----------------------------------------------------------------------===

//===---- stdint.h - Standard header for sized integer types --------------===* *
//  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://llvm.org/LICENSE.txt for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// \*===----------------------------------------------------------------------===

// Implement GCC bit scan builtins for MSVC

//  Throughout LZFSE we refer to "L", "M" and "D"; these will always appear as
//  a triplet, and represent a "usual" LZ-style literal and match pair.  "L"
//  is the number of literal bytes, "M" is the number of match bytes, and "D"
//  is the match "distance"; the distance in bytes between the current pointer
//  and the start of the match.

//  LZFSE internal status. These values are used by internal LZFSE routines
//  as return codes.  There should not be any good reason to change their
//  values; it is plausible that additional codes might be added in the
//  future.

//  Type representing an offset between elements in a buffer. On 64-bit
//  systems, this is stored in a 64-bit container to avoid extra sign-
//  extension operations in addressing arithmetic, but the value is always
//  representable as a 32-bit signed value in LZFSE's usage.
type lzfse_offset = int64_t /* lzfse_internal.h:115:17 */

// ! @abstract History table set. Each line of the history table represents a set
//  of candidate match locations, each of which begins with four bytes with the
//  same hash. The table contains not only the positions, but also the first
//  four bytes at each position. This doubles the memory footprint of the
//  table, but allows us to quickly eliminate false-positive matches without
//  doing any pointer chasing and without pulling in any additional cachelines.
//  This provides a large performance win in practice.
type lzfse_history_set = struct {
	pos   [4]int32_t
	value [4]uint32_t
} /* lzfse_internal.h:130:3 */

// ! @abstract An lzfse match is a sequence of bytes in the source buffer that
//  exactly matches an earlier (but possibly overlapping) sequence of bytes in
//  the same buffer.
//  @code
//  exeMPLARYexaMPLE
//  |  |     | ||-|--- lzfse_match2.length=3
//  |  |     | ||----- lzfse_match2.pos
//  |  |     |-|------ lzfse_match1.length=3
//  |  |     |-------- lzfse_match1.pos
//  |  |-------------- lzfse_match2.ref
//  |----------------- lzfse_match1.ref
//  @endcode
type lzfse_match = struct {
	pos    lzfse_offset
	ref    lzfse_offset
	length uint32_t
	_      [4]byte
} /* lzfse_internal.h:153:3 */

// MARK: - Encoder and Decoder state objects

//! @abstract Encoder state object.
type lzfse_encoder_state = struct {
	src            uintptr
	src_end        lzfse_offset
	src_literal    lzfse_offset
	src_encode_i   lzfse_offset
	src_encode_end lzfse_offset
	dst            uintptr
	dst_begin      uintptr
	dst_end        uintptr
	pending        lzfse_match
	n_matches      uint32_t
	n_literals     uint32_t
	l_values       [10000]uint32_t
	m_values       [10000]uint32_t
	d_values       [10000]uint32_t
	literals       [40000]uint8_t
	history_table  [16384]lzfse_history_set
} /* lzfse_internal.h:204:3 */

//! @abstract Decoder state object for lzfse compressed blocks.
type lzfse_compressed_block_decoder_state = struct {
	n_matches           uint32_t
	n_lmd_payload_bytes uint32_t
	current_literal     uintptr
	l_value             int32_t
	m_value             int32_t
	d_value             int32_t
	_                   [4]byte
	lmd_in_stream       fse_in_stream
	lmd_in_buf          uint32_t
	l_state             uint16_t
	m_state             uint16_t
	d_state             uint16_t
	_                   [2]byte
	l_decoder           [64]fse_value_decoder_entry
	m_decoder           [64]fse_value_decoder_entry
	d_decoder           [256]fse_value_decoder_entry
	literal_decoder     [1024]int32_t
	literals            [40064]uint8_t
	_                   [4]byte
} /* lzfse_internal.h:236:3 */

//  Decoder state object for uncompressed blocks.
type uncompressed_block_decoder_state = struct{ n_raw_bytes uint32_t } /* lzfse_internal.h:239:42 */

//! @abstract Decoder state object for lzvn-compressed blocks.
type lzvn_compressed_block_decoder_state = struct {
	n_raw_bytes     uint32_t
	n_payload_bytes uint32_t
	d_prev          uint32_t
} /* lzfse_internal.h:246:3 */

//! @abstract Decoder state object.
type lzfse_decoder_state = struct {
	src                          uintptr
	src_begin                    uintptr
	src_end                      uintptr
	dst                          uintptr
	dst_begin                    uintptr
	dst_end                      uintptr
	end_of_stream                int32
	block_magic                  uint32_t
	compressed_lzfse_block_state lzfse_compressed_block_decoder_state
	compressed_lzvn_block_state  lzvn_compressed_block_decoder_state
	uncompressed_block_state     uncompressed_block_decoder_state
} /* lzfse_internal.h:272:3 */

// MARK: - Block header objects

//! @abstract Uncompressed block header in encoder stream.
type uncompressed_block_header = struct {
	magic       uint32_t
	n_raw_bytes uint32_t
} /* lzfse_internal.h:289:3 */

//! @abstract Compressed block header with uncompressed tables.
type lzfse_compressed_block_header_v1 = struct {
	magic                   uint32_t
	n_raw_bytes             uint32_t
	n_payload_bytes         uint32_t
	n_literals              uint32_t
	n_matches               uint32_t
	n_literal_payload_bytes uint32_t
	n_lmd_payload_bytes     uint32_t
	literal_bits            int32_t
	literal_state           [4]uint16_t
	lmd_bits                int32_t
	l_state                 uint16_t
	m_state                 uint16_t
	d_state                 uint16_t
	l_freq                  [20]uint16_t
	m_freq                  [20]uint16_t
	d_freq                  [64]uint16_t
	literal_freq            [256]uint16_t
	_                       [2]byte
} /* lzfse_internal.h:330:3 */

// ! @abstract Compressed block header with compressed tables. Note that because
//  freq[] is compressed, the structure-as-stored-in-the-stream is *truncated*;
//  we only store the used bytes of freq[]. This means that some extra care must
//  be taken when reading one of these headers from the stream.
type lzfse_compressed_block_header_v2 = struct {
	magic         uint32_t
	n_raw_bytes   uint32_t
	packed_fields [3]uint64_t
	freq          [720]uint8_t
} /* lzfse_internal.h:374:1 */

//! @abstract LZVN compressed block header.
type lzvn_compressed_block_header = struct {
	magic           uint32_t
	n_raw_bytes     uint32_t
	n_payload_bytes uint32_t
} /* lzfse_internal.h:384:3 */

//! @abstract Signed offset in buffers, stored on either 32 or 64 bits.
type lzvn_offset = int64_t /* lzfse_internal.h:418:17 */

// MARK: - LZFSE utility functions

//! @abstract Load bytes from memory location SRC.
func load2(tls *libc.TLS, ptr uintptr) uint16_t { /* lzfse_internal.h:426:23: */
	bp := tls.Alloc(2)
	defer tls.Free(2)

	// var data uint16_t at bp, 2

	libc.X__builtin___memcpy_chk(tls, bp, ptr, uint64(unsafe.Sizeof(uint16_t(0))), libc.X__builtin_object_size(tls, bp, 0))
	return uint16_t(**(**uint16_t)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* data */))
}

func load4(tls *libc.TLS, ptr uintptr) uint32_t { /* lzfse_internal.h:432:23: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var data uint32_t at bp, 4

	libc.X__builtin___memcpy_chk(tls, bp, ptr, uint64(unsafe.Sizeof(uint32_t(0))), libc.X__builtin_object_size(tls, bp, 0))
	return uint32_t(**(**uint32_t)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* data */))
}

func load8(tls *libc.TLS, ptr uintptr) uint64_t { /* lzfse_internal.h:438:23: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var data uint64_t at bp, 8

	libc.X__builtin___memcpy_chk(tls, bp, ptr, uint64(unsafe.Sizeof(uint64_t(0))), libc.X__builtin_object_size(tls, bp, 0))
	return uint64_t(**(**uint64_t)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* data */))
}

//! @abstract Store bytes to memory location DST.
func store2(tls *libc.TLS, ptr uintptr, data uint16_t) { /* lzfse_internal.h:445:19: */
	bp := tls.Alloc(2)
	defer tls.Free(2)
	**(**uint16_t)(unsafe.Pointer(uintptr(bp))) = data

	libc.X__builtin___memcpy_chk(tls, ptr, bp, uint64(unsafe.Sizeof(uint16_t(0))), libc.X__builtin_object_size(tls, ptr, 0))
}

func store4(tls *libc.TLS, ptr uintptr, data uint32_t) { /* lzfse_internal.h:449:19: */
	bp := tls.Alloc(4)
	defer tls.Free(4)
	**(**uint32_t)(unsafe.Pointer(uintptr(bp))) = data

	libc.X__builtin___memcpy_chk(tls, ptr, bp, uint64(unsafe.Sizeof(uint32_t(0))), libc.X__builtin_object_size(tls, ptr, 0))
}

func store8(tls *libc.TLS, ptr uintptr, data uint64_t) { /* lzfse_internal.h:453:19: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	**(**uint64_t)(unsafe.Pointer(uintptr(bp))) = data

	libc.X__builtin___memcpy_chk(tls, ptr, bp, uint64(unsafe.Sizeof(uint64_t(0))), libc.X__builtin_object_size(tls, ptr, 0))
}

// ! @abstract Load+store bytes from locations SRC to DST. Not intended for use
// with overlapping buffers. Note that for LZ-style compression, you need
// copies to behave like naive memcpy( ) implementations do, splatting the
// leading sequence if the buffers overlap. This copy does not do that, so
// should not be used with overlapping buffers.
func copy8(tls *libc.TLS, dst uintptr, src uintptr) { /* lzfse_internal.h:462:19: */
	store8(tls, dst, load8(tls, src))
}

func copy16(tls *libc.TLS, dst uintptr, src uintptr) { /* lzfse_internal.h:463:19: */
	var m0 uint64_t = load8(tls, src)
	var m1 uint64_t = load8(tls, src+uintptr(8))
	store8(tls, dst, m0)
	store8(tls, dst+uintptr(8), m1)
}

// ===============================================================
// Bitfield Operations

// ! @abstract Extracts \p width bits from \p container, starting with \p lsb; if
// we view \p container as a bit array, we extract \c container[lsb:lsb+width].
func extract(tls *libc.TLS, container uintmax_t, lsb uint32, width uint32) uintmax_t { /* lzfse_internal.h:475:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(size_t(lsb) < container_width12)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__86)), ts+uintptr(438), 478, ts+uintptr(499))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(width > uint32(0) && size_t(width) <= container_width12)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__86)), ts+uintptr(438), 479, ts+uintptr(521))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(size_t(lsb+width) <= container_width12)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__86)), ts+uintptr(438), 480, ts+uintptr(559))
	} else {
	}
	if size_t(width) == container_width12 {
		return container
	}
	return container >> lsb & (uintmax_t(uint64(1))<<width - uint64(1))
}

var __func__86 = *(*[8]int8)(unsafe.Pointer(ts + uintptr(590)))                /* lzfse_internal.h:476:48 */
var container_width12 size_t = uint64(unsafe.Sizeof(uintmax_t(0))) * uint64(8) /* lzfse_internal.h:477:23 */

// ! @abstract Perform sanity checks on the values of lzfse_compressed_block_header_v1.
// Test that the field values are in the allowed limits, verify that the
// frequency tables sum to value less than total number of states.
// @return 0 if all tests passed.
// @return negative error code with 1 bit set for each failed test.
func lzfse_check_block_header_v1(tls *libc.TLS, header uintptr) int32 { /* lzfse_internal.h:511:18: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var tests_results int32 = 0
	tests_results = tests_results | func() int32 {
		if (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&header))).magic == uint32_t(0x31787662) {
			return 0
		}
		return int32(1) << 0
	}()
	tests_results = tests_results | func() int32 {
		if (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&header))).n_literals <= uint32_t(4*10000) {
			return 0
		}
		return int32(1) << 1
	}()
	tests_results = tests_results | func() int32 {
		if (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&header))).n_matches <= uint32_t(10000) {
			return 0
		}
		return int32(1) << 2
	}()
	// var literal_state [4]uint16_t at bp, 8

	libc.X__builtin___memcpy_chk(tls, bp, header+32, uint64(unsafe.Sizeof(uint16_t(0)))*uint64(4), libc.X__builtin_object_size(tls, bp, 0))

	tests_results = tests_results | func() int32 {
		if int32(*(*uint16_t)(unsafe.Pointer(bp))) < 1024 {
			return 0
		}
		return int32(1) << 3
	}()
	tests_results = tests_results | func() int32 {
		if int32(*(*uint16_t)(unsafe.Pointer(bp + 1*2))) < 1024 {
			return 0
		}
		return int32(1) << 4
	}()
	tests_results = tests_results | func() int32 {
		if int32(*(*uint16_t)(unsafe.Pointer(bp + 2*2))) < 1024 {
			return 0
		}
		return int32(1) << 5
	}()
	tests_results = tests_results | func() int32 {
		if int32(*(*uint16_t)(unsafe.Pointer(bp + 3*2))) < 1024 {
			return 0
		}
		return int32(1) << 6
	}()

	tests_results = tests_results | func() int32 {
		if int32((**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&header))).l_state) < 64 {
			return 0
		}
		return int32(1) << 7
	}()
	tests_results = tests_results | func() int32 {
		if int32((**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&header))).m_state) < 64 {
			return 0
		}
		return int32(1) << 8
	}()
	tests_results = tests_results | func() int32 {
		if int32((**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&header))).d_state) < 256 {
			return 0
		}
		return int32(1) << 9
	}()
	var res int32
	res = fse_check_freq(tls, header+50, uint64(20),
		uint64(64))
	tests_results = tests_results | func() int32 {
		if res == 0 {
			return 0
		}
		return int32(1) << 10
	}()
	res = fse_check_freq(tls, header+90, uint64(20),
		uint64(64))
	tests_results = tests_results | func() int32 {
		if res == 0 {
			return 0
		}
		return int32(1) << 11
	}()
	res = fse_check_freq(tls, header+130, uint64(64),
		uint64(256))
	tests_results = tests_results | func() int32 {
		if res == 0 {
			return 0
		}
		return int32(1) << 12
	}()
	res = fse_check_freq(tls, header+258, uint64(256),
		uint64(1024))
	tests_results = tests_results | func() int32 {
		if res == 0 {
			return 0
		}
		return int32(1) << 13
	}()

	if tests_results != 0 {
		return int32(uint32(tests_results) | 0x80000000) // each 1 bit is a test that failed
		// (except for the sign bit)
	}

	return 0 // OK
}

//! @abstract Base decoder state.
type lzvn_decoder_state = struct {
	src           uintptr
	src_end       uintptr
	dst           uintptr
	dst_begin     uintptr
	dst_end       uintptr
	dst_current   uintptr
	L             size_t
	M             size_t
	D             size_t
	d_prev        lzvn_offset
	end_of_stream int32
	_             [4]byte
} /* lzvn_decode_base.h:62:3 */

//  Both the source and destination buffers are represented by a pointer and
//  a length; they are *always* updated in concert using this macro; however
//  many bytes the pointer is advanced, the length is decremented by the same
//  amount. Thus, pointer + length always points to the byte one past the end
//  of the buffer.

//  Update state with current positions and distance, corresponding to the
//  beginning of an instruction in both streams

func lzvn_decode(tls *libc.TLS, state uintptr) { /* lzvn_decode_base.c:47:6: */
	var src_len size_t
	var dst_len size_t // empty buffer

	var src_ptr uintptr
	var dst_ptr uintptr
	var D size_t
	var M size_t
	var L size_t
	var opc_len size_t
	var opc uint8
	var i size_t
	var i1 size_t
	var i2 size_t
	var i3 size_t
	var i4 size_t
	var i5 size_t
	var i6 size_t
	var i7 size_t // source truncated
	var opc23 uint16_t
	src_len = size_t((int64((**(**lzvn_decoder_state)(unsafe.Pointer(&state))).src_end) - int64((**(**lzvn_decoder_state)(unsafe.Pointer(&state))).src)) / 1)
	dst_len = size_t((int64((**(**lzvn_decoder_state)(unsafe.Pointer(&state))).dst_end) - int64((**(**lzvn_decoder_state)(unsafe.Pointer(&state))).dst)) / 1)
	if !(src_len == uint64(0) || dst_len == uint64(0)) {
		goto __1
	}
	return
__1:
	;
	src_ptr = (**(**lzvn_decoder_state)(unsafe.Pointer(&state))).src
	dst_ptr = (**(**lzvn_decoder_state)(unsafe.Pointer(&state))).dst
	D = size_t((**(**lzvn_decoder_state)(unsafe.Pointer(&state))).d_prev)

	// Do we have a partially expanded match saved in state?
	if !((**(**lzvn_decoder_state)(unsafe.Pointer(&state))).L != uint64(0) || (**(**lzvn_decoder_state)(unsafe.Pointer(&state))).M != uint64(0)) {
		goto __2
	}
	L = (**(**lzvn_decoder_state)(unsafe.Pointer(&state))).L
	M = (**(**lzvn_decoder_state)(unsafe.Pointer(&state))).M
	D = (**(**lzvn_decoder_state)(unsafe.Pointer(&state))).D
	opc_len = uint64(0) // we already skipped the op
	(*lzvn_decoder_state)(unsafe.Pointer(state)).L = libc.AssignPtrUint64(state+56, libc.AssignPtrUint64(state+64, uint64(0)))
	if !(M == uint64(0)) {
		goto __3
	}
	goto copy_literal
__3:
	;
	if !(L == uint64(0)) {
		goto __4
	}
	goto copy_match
__4:
	;
	goto copy_literal_and_match
__2:
	;
	opc = *(*uint8)(unsafe.Pointer(src_ptr))

__5:
	switch int32(opc) {
	case 0:
		goto __9
	case 1:
		goto __10
	case 2:
		goto __11
	case 3:
		goto __12
	case 4:
		goto __13
	case 5:
		goto __14
	case 8:
		goto __15
	case 9:
		goto __16
	case 10:
		goto __17
	case 11:
		goto __18
	case 12:
		goto __19
	case 13:
		goto __20
	case 16:
		goto __21
	case 17:
		goto __22
	case 18:
		goto __23
	case 19:
		goto __24
	case 20:
		goto __25
	case 21:
		goto __26
	case 24:
		goto __27
	case 25:
		goto __28
	case 26:
		goto __29
	case 27:
		goto __30
	case 28:
		goto __31
	case 29:
		goto __32
	case 32:
		goto __33
	case 33:
		goto __34
	case 34:
		goto __35
	case 35:
		goto __36
	case 36:
		goto __37
	case 37:
		goto __38
	case 40:
		goto __39
	case 41:
		goto __40
	case 42:
		goto __41
	case 43:
		goto __42
	case 44:
		goto __43
	case 45:
		goto __44
	case 48:
		goto __45
	case 49:
		goto __46
	case 50:
		goto __47
	case 51:
		goto __48
	case 52:
		goto __49
	case 53:
		goto __50
	case 56:
		goto __51
	case 57:
		goto __52
	case 58:
		goto __53
	case 59:
		goto __54
	case 60:
		goto __55
	case 61:
		goto __56
	case 64:
		goto __57
	case 65:
		goto __58
	case 66:
		goto __59
	case 67:
		goto __60
	case 68:
		goto __61
	case 69:
		goto __62
	case 72:
		goto __63
	case 73:
		goto __64
	case 74:
		goto __65
	case 75:
		goto __66
	case 76:
		goto __67
	case 77:
		goto __68
	case 80:
		goto __69
	case 81:
		goto __70
	case 82:
		goto __71
	case 83:
		goto __72
	case 84:
		goto __73
	case 85:
		goto __74
	case 88:
		goto __75
	case 89:
		goto __76
	case 90:
		goto __77
	case 91:
		goto __78
	case 92:
		goto __79
	case 93:
		goto __80
	case 96:
		goto __81
	case 97:
		goto __82
	case 98:
		goto __83
	case 99:
		goto __84
	case 100:
		goto __85
	case 101:
		goto __86
	case 104:
		goto __87
	case 105:
		goto __88
	case 106:
		goto __89
	case 107:
		goto __90
	case 108:
		goto __91
	case 109:
		goto __92
	case 128:
		goto __93
	case 129:
		goto __94
	case 130:
		goto __95
	case 131:
		goto __96
	case 132:
		goto __97
	case 133:
		goto __98
	case 136:
		goto __99
	case 137:
		goto __100
	case 138:
		goto __101
	case 139:
		goto __102
	case 140:
		goto __103
	case 141:
		goto __104
	case 144:
		goto __105
	case 145:
		goto __106
	case 146:
		goto __107
	case 147:
		goto __108
	case 148:
		goto __109
	case 149:
		goto __110
	case 152:
		goto __111
	case 153:
		goto __112
	case 154:
		goto __113
	case 155:
		goto __114
	case 156:
		goto __115
	case 157:
		goto __116
	case 192:
		goto __117
	case 193:
		goto __118
	case 194:
		goto __119
	case 195:
		goto __120
	case 196:
		goto __121
	case 197:
		goto __122
	case 200:
		goto __123
	case 201:
		goto __124
	case 202:
		goto __125
	case 203:
		goto __126
	case 204:
		goto __127
	case 205:
		goto __128
	case 160:
		goto __129
	case 161:
		goto __130
	case 162:
		goto __131
	case 163:
		goto __132
	case 164:
		goto __133
	case 165:
		goto __134
	case 166:
		goto __135
	case 167:
		goto __136
	case 168:
		goto __137
	case 169:
		goto __138
	case 170:
		goto __139
	case 171:
		goto __140
	case 172:
		goto __141
	case 173:
		goto __142
	case 174:
		goto __143
	case 175:
		goto __144
	case 176:
		goto __145
	case 177:
		goto __146
	case 178:
		goto __147
	case 179:
		goto __148
	case 180:
		goto __149
	case 181:
		goto __150
	case 182:
		goto __151
	case 183:
		goto __152
	case 184:
		goto __153
	case 185:
		goto __154
	case 186:
		goto __155
	case 187:
		goto __156
	case 188:
		goto __157
	case 189:
		goto __158
	case 190:
		goto __159
	case 191:
		goto __160
	case 7:
		goto __161
	case 15:
		goto __162
	case 23:
		goto __163
	case 31:
		goto __164
	case 39:
		goto __165
	case 47:
		goto __166
	case 55:
		goto __167
	case 63:
		goto __168
	case 71:
		goto __169
	case 79:
		goto __170
	case 87:
		goto __171
	case 95:
		goto __172
	case 103:
		goto __173
	case 111:
		goto __174
	case 135:
		goto __175
	case 143:
		goto __176
	case 151:
		goto __177
	case 159:
		goto __178
	case 199:
		goto __179
	case 207:
		goto __180
	case 70:
		goto __181
	case 78:
		goto __182
	case 86:
		goto __183
	case 94:
		goto __184
	case 102:
		goto __185
	case 110:
		goto __186
	case 134:
		goto __187
	case 142:
		goto __188
	case 150:
		goto __189
	case 158:
		goto __190
	case 198:
		goto __191
	case 206:
		goto __192
	case 241:
		goto __193
	case 242:
		goto __194
	case 243:
		goto __195
	case 244:
		goto __196
	case 245:
		goto __197
	case 246:
		goto __198
	case 247:
		goto __199
	case 248:
		goto __200
	case 249:
		goto __201
	case 250:
		goto __202
	case 251:
		goto __203
	case 252:
		goto __204
	case 253:
		goto __205
	case 254:
		goto __206
	case 255:
		goto __207
	case 240:
		goto __208
	case 225:
		goto __209
	case 226:
		goto __210
	case 227:
		goto __211
	case 228:
		goto __212
	case 229:
		goto __213
	case 230:
		goto __214
	case 231:
		goto __215
	case 232:
		goto __216
	case 233:
		goto __217
	case 234:
		goto __218
	case 235:
		goto __219
	case 236:
		goto __220
	case 237:
		goto __221
	case 238:
		goto __222
	case 239:
		goto __223
	case 224:
		goto __224
	case 14:
		goto __225
	case 22:
		goto __226
	case 6:
		goto __227
	case 30:
		goto __228
	case 38:
		goto __229
	case 46:
		goto __230
	case 54:
		goto __231
	case 62:
		goto __232
	case 112:
		goto __233
	case 113:
		goto __234
	case 114:
		goto __235
	case 115:
		goto __236
	case 116:
		goto __237
	case 117:
		goto __238
	case 118:
		goto __239
	case 119:
		goto __240
	case 120:
		goto __241
	case 121:
		goto __242
	case 122:
		goto __243
	case 123:
		goto __244
	case 124:
		goto __245
	case 125:
		goto __246
	case 126:
		goto __247
	case 127:
		goto __248
	case 208:
		goto __249
	case 209:
		goto __250
	case 210:
		goto __251
	case 211:
		goto __252
	case 212:
		goto __253
	case 213:
		goto __254
	case 214:
		goto __255
	case 215:
		goto __256
	case 216:
		goto __257
	case 217:
		goto __258
	case 218:
		goto __259
	case 219:
		goto __260
	case 220:
		goto __261
	case 221:
		goto __262
	case 222:
		goto __263
	case 223:
		goto __264
	}
	goto __8
	goto sml_d
	//  ===============================================================
	//  These four opcodes (sml_d, med_d, lrg_d, and pre_d) encode both a
	//  literal and a match. The bulk of their implementations are shared;
	//  each label here only does the work of setting the opcode length (not
	//  including any literal bytes), and extracting the literal length, match
	//  length, and match distance (except in pre_d). They then jump into the
	//  shared implementation to actually output the literal and match bytes.
	//
	//  No error checking happens in the first stage, except for ensuring that
	//  the source has enough length to represent the full opcode before
	//  reading past the first byte.
sml_d:
__9:
__10:
__11:
__12:
__13:
__14:
__15:
__16:
__17:
__18:
__19:
__20:
__21:
__22:
__23:
__24:
__25:
__26:
__27:
__28:
__29:
__30:
__31:
__32:
__33:
__34:
__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
__50:
__51:
__52:
__53:
__54:
__55:
__56:
__57:
__58:
__59:
__60:
__61:
__62:
__63:
__64:
__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
__74:
__75:
__76:
__77:
__78:
__79:
__80:
__81:
__82:
__83:
__84:
__85:
__86:
__87:
__88:
__89:
__90:
__91:
__92:
__93:
__94:
__95:
__96:
__97:
__98:
__99:
__100:
__101:
__102:
__103:
__104:
__105:
__106:
__107:
__108:
__109:
__110:
__111:
__112:
__113:
__114:
__115:
__116:
__117:
__118:
__119:
__120:
__121:
__122:
__123:
__124:
__125:
__126:
__127:
__128:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	// "small distance": This opcode has the structure LLMMMDDD DDDDDDDD LITERAL
	//  where the length of literal (0-3 bytes) is encoded by the high 2 bits of
	//  the first byte. We first extract the literal length so we know how long
	//  the opcode is, then check that the source can hold both this opcode and
	//  at least one byte of the next (because any valid input stream must be
	//  terminated with an eos token).
	opc_len = uint64(2)
	L = extract(tls, uint64(opc), uint32(6), uint32(2))
	M = extract(tls, uint64(opc), uint32(3), uint32(3)) + uint64(3)
	//  We need to ensure that the source buffer is long enough that we can
	//  safely read this entire opcode, the literal that follows, and the first
	//  byte of the next opcode.  Once we satisfy this requirement, we can
	//  safely unpack the match distance. A check similar to this one is
	//  present in all the opcode implementations.
	if !(src_len <= opc_len+L) {
		goto __265
	}
	return
__265:
	; // source truncated
	D = extract(tls, uint64(opc), uint32(0), uint32(3))<<8 | size_t(*(*uint8)(unsafe.Pointer(src_ptr + 1)))
	goto copy_literal_and_match
	goto med_d

med_d:
__129:
__130:
__131:
__132:
__133:
__134:
__135:
__136:
__137:
__138:
__139:
__140:
__141:
__142:
__143:
__144:
__145:
__146:
__147:
__148:
__149:
__150:
__151:
__152:
__153:
__154:
__155:
__156:
__157:
__158:
__159:
__160:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	//  "medium distance": This is a minor variant of the "small distance"
	//  encoding, where we will now use two extra bytes instead of one to encode
	//  the restof the match length and distance. This allows an extra two bits
	//  for the match length, and an extra three bits for the match distance. The
	//  full structure of the opcode is 101LLMMM DDDDDDMM DDDDDDDD LITERAL.
	opc_len = uint64(3)
	L = extract(tls, uint64(opc), uint32(3), uint32(2))
	if !(src_len <= opc_len+L) {
		goto __266
	}
	return
__266:
	;
	opc23 = load2(tls, src_ptr+1)
	M = extract(tls, uint64(opc), uint32(0), uint32(3))<<2 | extract(tls, uint64(opc23), uint32(0), uint32(2)) + uint64(3)
	D = extract(tls, uint64(opc23), uint32(2), uint32(14))
	goto copy_literal_and_match
	goto lrg_d

lrg_d:
__161:
__162:
__163:
__164:
__165:
__166:
__167:
__168:
__169:
__170:
__171:
__172:
__173:
__174:
__175:
__176:
__177:
__178:
__179:
__180:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	//  "large distance": This is another variant of the "small distance"
	//  encoding, where we will now use two extra bytes to encode the match
	//  distance, which allows distances up to 65535 to be represented. The full
	//  structure of the opcode is LLMMM111 DDDDDDDD DDDDDDDD LITERAL.
	opc_len = uint64(3)
	L = extract(tls, uint64(opc), uint32(6), uint32(2))
	M = extract(tls, uint64(opc), uint32(3), uint32(3)) + uint64(3)
	if !(src_len <= opc_len+L) {
		goto __267
	}
	return
__267:
	; // source truncated
	D = size_t(load2(tls, src_ptr+1))
	goto copy_literal_and_match
	goto pre_d

pre_d:
__181:
__182:
__183:
__184:
__185:
__186:
__187:
__188:
__189:
__190:
__191:
__192:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	//  "previous distance": This opcode has the structure LLMMM110, where the
	//  length of the literal (0-3 bytes) is encoded by the high 2 bits of the
	//  first byte. We first extract the literal length so we know how long
	//  the opcode is, then check that the source can hold both this opcode and
	//  at least one byte of the next (because any valid input stream must be
	//  terminated with an eos token).
	opc_len = uint64(1)
	L = extract(tls, uint64(opc), uint32(6), uint32(2))
	M = extract(tls, uint64(opc), uint32(3), uint32(3)) + uint64(3)
	if !(src_len <= opc_len+L) {
		goto __268
	}
	return
__268:
	; // source truncated
	goto copy_literal_and_match

copy_literal_and_match:
	//  Common implementation of writing data for opcodes that have both a
	//  literal and a match. We begin by advancing the source pointer past
	//  the opcode, so that it points at the first literal byte (if L
	//  is non-zero; otherwise it points at the next opcode).
	src_ptr += uintptr(opc_len)
	src_len = src_len - opc_len
	//  Now we copy the literal from the source pointer to the destination.
	if !(libc.X__builtin_expect(tls, int64(libc.Bool32(dst_len >= uint64(4) && src_len >= uint64(4))), int64(1)) != 0) {
		goto __269
	}
	//  The literal is 0-3 bytes; if we are not near the end of the buffer,
	//  we can safely just do a 4 byte copy (which is guaranteed to cover
	//  the complete literal, and may include some other bytes as well).
	store4(tls, dst_ptr, load4(tls, src_ptr))
	goto __270
__269:
	if !(L <= dst_len) {
		goto __271
	}
	//  We are too close to the end of either the input or output stream
	//  to be able to safely use a four-byte copy, but we will not exhaust
	//  either stream (we already know that the source will not be
	//  exhausted from checks in the individual opcode implementations,
	//  and we just tested that dst_len > L). Thus, we need to do a
	//  byte-by-byte copy of the literal. This is slow, but it can only ever
	//  happen near the very end of a buffer, so it is not an important case to
	//  optimize.
	{
		i = uint64(0)
	__273:
		if !(i < L) {
			goto __275
		}
		*(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i))) = *(*uint8)(unsafe.Pointer(src_ptr + uintptr(i)))
		goto __274
	__274:
		i++
		goto __273
		goto __275
	__275:
	}
	goto __272
__271:
	// Destination truncated: fill DST, and store partial match

	// Copy partial literal
	{
		i1 = uint64(0)
	__276:
		if !(i1 < dst_len) {
			goto __278
		}
		*(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i1))) = *(*uint8)(unsafe.Pointer(src_ptr + uintptr(i1)))
		goto __277
	__277:
		i1++
		goto __276
		goto __278
	__278:
	}
	// Save state
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr + uintptr(dst_len)
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr + uintptr(dst_len)
	(*lzvn_decoder_state)(unsafe.Pointer(state)).L = L - dst_len
	(*lzvn_decoder_state)(unsafe.Pointer(state)).M = M
	(*lzvn_decoder_state)(unsafe.Pointer(state)).D = D
	return // destination truncated
__272:
	;
__270:
	;
	//  Having completed the copy of the literal, we advance both the source
	//  and destination pointers by the number of literal bytes.
	dst_ptr += uintptr(L)
	dst_len = dst_len - L
	src_ptr += uintptr(L)
	src_len = src_len - L
	//  Check if the match distance is valid; matches must not reference
	//  bytes that preceed the start of the output buffer, nor can the match
	//  distance be zero.
	if !(D > size_t((int64(dst_ptr)-int64((**(**lzvn_decoder_state)(unsafe.Pointer(&state))).dst_begin))/1) || D == uint64(0)) {
		goto __279
	}
	goto invalid_match_distance
__279:
	;
copy_match:
	//  Now we copy the match from dst_ptr - D to dst_ptr. It is important to keep
	//  in mind that we may have D < M, in which case the source and destination
	//  windows overlap in the copy. The semantics of the match copy are *not*
	//  those of memmove( ); if the buffers overlap it needs to behave as though
	//  we were copying byte-by-byte in increasing address order. If, for example,
	//  D is 1, the copy operation is equivalent to:
	//
	//      memset(dst_ptr, dst_ptr[-1], M);
	//
	//  i.e. it splats the previous byte. This means that we need to be very
	//  careful about using wide loads or stores to perform the copy operation.
	if !(libc.X__builtin_expect(tls, int64(libc.Bool32(dst_len >= M+uint64(7) && D >= uint64(8))), int64(1)) != 0) {
		goto __280
	}
	//  We are not near the end of the buffer, and the match distance
	//  is at least eight. Thus, we can safely loop using eight byte
	//  copies. The last of these may slop over the intended end of
	//  the match, but this is OK because we know we have a safety bound
	//  away from the end of the destination buffer.
	{
		i2 = uint64(0)
	__282:
		if !(i2 < M) {
			goto __284
		}
		store8(tls, dst_ptr+uintptr(i2), load8(tls, dst_ptr+uintptr(i2-D)))
		goto __283
	__283:
		i2 = i2 + uint64(8)
		goto __282
		goto __284
	__284:
	}
	goto __281
__280:
	if !(M <= dst_len) {
		goto __285
	}
	//  Either the match distance is too small, or we are too close to
	//  the end of the buffer to safely use eight byte copies. Fall back
	//  on a simple byte-by-byte implementation.
	{
		i3 = uint64(0)
	__287:
		if !(i3 < M) {
			goto __289
		}
		*(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i3))) = *(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i3-D)))
		goto __288
	__288:
		i3++
		goto __287
		goto __289
	__289:
	}
	goto __286
__285:
	// Destination truncated: fill DST, and store partial match

	// Copy partial match
	{
		i4 = uint64(0)
	__290:
		if !(i4 < dst_len) {
			goto __292
		}
		*(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i4))) = *(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i4-D)))
		goto __291
	__291:
		i4++
		goto __290
		goto __292
	__292:
	}
	// Save state
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr + uintptr(dst_len)
	(*lzvn_decoder_state)(unsafe.Pointer(state)).L = uint64(0)
	(*lzvn_decoder_state)(unsafe.Pointer(state)).M = M - dst_len
	(*lzvn_decoder_state)(unsafe.Pointer(state)).D = D
	return // destination truncated
__286:
	;
__281:
	;
	//  Update the destination pointer and length to account for the bytes
	//  written by the match, then load the next opcode byte and branch to
	//  the appropriate implementation.
	dst_ptr += uintptr(M)
	dst_len = dst_len - M
	opc = *(*uint8)(unsafe.Pointer(src_ptr))
	goto __8
	goto sml_m

	// ===============================================================
	// Opcodes representing only a match (no literal).
	//  These two opcodes (lrg_m and sml_m) encode only a match. The match
	//  distance is carried over from the previous opcode, so all they need
	//  to encode is the match length. We are able to reuse the match copy
	//  sequence from the literal and match opcodes to perform the actual
	//  copy implementation.
sml_m:
__193:
__194:
__195:
__196:
__197:
__198:
__199:
__200:
__201:
__202:
__203:
__204:
__205:
__206:
__207:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	//  "small match": This opcode has no literal, and uses the previous match
	//  distance (i.e. it encodes only the match length), in a single byte as
	//  1111MMMM.
	opc_len = uint64(1)
	if !(src_len <= opc_len) {
		goto __293
	}
	return
__293:
	; // source truncated
	M = extract(tls, uint64(opc), uint32(0), uint32(4))
	src_ptr += uintptr(opc_len)
	src_len = src_len - opc_len
	goto copy_match
	goto lrg_m

lrg_m:
__208:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	//  "large match": This opcode has no literal, and uses the previous match
	//  distance (i.e. it encodes only the match length). It is encoded in two
	//  bytes as 11110000 MMMMMMMM.  Because matches smaller than 16 bytes can
	//  be represented by sml_m, there is an implicit bias of 16 on the match
	//  length; the representable values are [16,271].
	opc_len = uint64(2)
	if !(src_len <= opc_len) {
		goto __294
	}
	return
__294:
	; // source truncated
	M = size_t(int32(*(*uint8)(unsafe.Pointer(src_ptr + 1))) + 16)
	src_ptr += uintptr(opc_len)
	src_len = src_len - opc_len
	goto copy_match
	goto sml_l

	// ===============================================================
	// Opcodes representing only a literal (no match).
	//  These two opcodes (lrg_l and sml_l) encode only a literal.  There is no
	//  match length or match distance to worry about (but we need to *not*
	//  touch D, as it must be preserved between opcodes).
sml_l:
__209:
__210:
__211:
__212:
__213:
__214:
__215:
__216:
__217:
__218:
__219:
__220:
__221:
__222:
__223:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	//  "small literal": This opcode has no match, and encodes only a literal
	//  of length up to 15 bytes. The format is 1110LLLL LITERAL.
	opc_len = uint64(1)
	L = extract(tls, uint64(opc), uint32(0), uint32(4))
	goto copy_literal
	goto lrg_l

lrg_l:
__224:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	//  "large literal": This opcode has no match, and uses the previous match
	//  distance (i.e. it encodes only the match length). It is encoded in two
	//  bytes as 11100000 LLLLLLLL LITERAL.  Because literals smaller than 16
	//  bytes can be represented by sml_l, there is an implicit bias of 16 on
	//  the literal length; the representable values are [16,271].
	opc_len = uint64(2)
	if !(src_len <= uint64(2)) {
		goto __295
	}
	return
__295:
	; // source truncated
	L = size_t(int32(*(*uint8)(unsafe.Pointer(src_ptr + 1))) + 16)
	goto copy_literal

copy_literal:
	//  Check that the source buffer is large enough to hold the complete
	//  literal and at least the first byte of the next opcode. If so, advance
	//  the source pointer to point to the first byte of the literal and adjust
	//  the source length accordingly.
	if !(src_len <= opc_len+L) {
		goto __296
	}
	return
__296:
	; // source truncated
	src_ptr += uintptr(opc_len)
	src_len = src_len - opc_len
	//  Now we copy the literal from the source pointer to the destination.
	if !(dst_len >= L+uint64(7) && src_len >= L+uint64(7)) {
		goto __297
	}
	//  We are not near the end of the source or destination buffers; thus
	//  we can safely copy the literal using wide copies, without worrying
	//  about reading or writing past the end of either buffer.
	{
		i5 = uint64(0)
	__299:
		if !(i5 < L) {
			goto __301
		}
		store8(tls, dst_ptr+uintptr(i5), load8(tls, src_ptr+uintptr(i5)))
		goto __300
	__300:
		i5 = i5 + uint64(8)
		goto __299
		goto __301
	__301:
	}
	goto __298
__297:
	if !(L <= dst_len) {
		goto __302
	}
	//  We are too close to the end of either the input or output stream
	//  to be able to safely use an eight-byte copy. Instead we copy the
	//  literal byte-by-byte.
	{
		i6 = uint64(0)
	__304:
		if !(i6 < L) {
			goto __306
		}
		*(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i6))) = *(*uint8)(unsafe.Pointer(src_ptr + uintptr(i6)))
		goto __305
	__305:
		i6++
		goto __304
		goto __306
	__306:
	}
	goto __303
__302:
	// Destination truncated: fill DST, and store partial match

	// Copy partial literal
	{
		i7 = uint64(0)
	__307:
		if !(i7 < dst_len) {
			goto __309
		}
		*(*uint8)(unsafe.Pointer(dst_ptr + uintptr(i7))) = *(*uint8)(unsafe.Pointer(src_ptr + uintptr(i7)))
		goto __308
	__308:
		i7++
		goto __307
		goto __309
	__309:
	}
	// Save state
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr + uintptr(dst_len)
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr + uintptr(dst_len)
	(*lzvn_decoder_state)(unsafe.Pointer(state)).L = L - dst_len
	(*lzvn_decoder_state)(unsafe.Pointer(state)).M = uint64(0)
	(*lzvn_decoder_state)(unsafe.Pointer(state)).D = D
	return // destination truncated
__303:
	;
__298:
	;
	//  Having completed the copy of the literal, we advance both the source
	//  and destination pointers by the number of literal bytes.
	dst_ptr += uintptr(L)
	dst_len = dst_len - L
	src_ptr += uintptr(L)
	src_len = src_len - L
	//  Load the first byte of the next opcode, and jump to its implementation.
	opc = *(*uint8)(unsafe.Pointer(src_ptr))
	goto __8
	goto nop

	// ===============================================================
	// Other opcodes
nop:
__225:
__226:
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	opc_len = uint64(1)
	if !(src_len <= opc_len) {
		goto __310
	}
	return
__310:
	; // source truncated
	src_ptr += uintptr(opc_len)
	src_len = src_len - opc_len
	opc = *(*uint8)(unsafe.Pointer(src_ptr))
	goto __8
	goto eos

eos:
__227:
	opc_len = uint64(8)
	if !(src_len < opc_len) {
		goto __311
	}
	return
__311:
	; // source truncated (here we don't need an extra byte for next op
	// code)
	src_ptr += uintptr(opc_len)
	src_len = src_len - opc_len
	(*lzvn_decoder_state)(unsafe.Pointer(state)).end_of_stream = 1
	(*lzvn_decoder_state)(unsafe.Pointer(state)).src = src_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).dst = dst_ptr
	(*lzvn_decoder_state)(unsafe.Pointer(state)).d_prev = lzvn_offset(D)
	return
	goto udef // end-of-stream

	// ===============================================================
	// Return on error
udef:
__228:
__229:
__230:
__231:
__232:
__233:
__234:
__235:
__236:
__237:
__238:
__239:
__240:
__241:
__242:
__243:
__244:
__245:
__246:
__247:
__248:
__249:
__250:
__251:
__252:
__253:
__254:
__255:
__256:
__257:
__258:
__259:
__260:
__261:
__262:
__263:
__264:
invalid_match_distance:

	return // we already updated state
__8:
	;
	goto __6
__6:
	goto __5
	goto __7
__7:
}

func lzfse_encode_scratch_size(tls *libc.TLS) size_t { /* lzfse_encode.c:27:8: */
	var s1 size_t = size_t(unsafe.Sizeof(lzfse_encoder_state{}))
	var s2 size_t = lzvn_encode_scratch_size(tls)
	if s1 > s2 {
		return s1
	}
	return s2 // max(lzfse,lzvn)
}

func lzfse_encode_buffer_with_scratch(tls *libc.TLS, dst_buffer uintptr, dst_size size_t, src_buffer uintptr, src_size size_t, scratch_buffer uintptr) size_t { /* lzfse_encode.c:33:8: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var original_size size_t
	// need header + end-of-stream marker
	var extra_size size_t // DST is really too small, give up

	var sz size_t // failed, or no compression, fall back to
	// uncompressed block

	// If we could encode, setup header and end-of-stream marker (we left room
	// for them, no need to test)
	// var header lzvn_compressed_block_header at bp, 12

	//  lzfse only uses 32 bits for offsets internally, so if the input
	//  buffer is really huge, we need to process it in smaller chunks.
	//  Note that we switch over to this path for sizes much smaller
	//  2GB because it's actually faster to change algorithms well before
	//  it's necessary for correctness.
	//  The first chunk, we just process normally.
	var encoder_block_size lzfse_offset
	var state uintptr
	// var header1 uncompressed_block_header at bp+uintptr(12), 8

	var dst_end uintptr
	original_size = src_size

	// If input is really really small, go directly to uncompressed buffer
	// (because LZVN will refuse to encode it, and we will report a failure)
	if !(src_size < uint64(8)) {
		goto __1
	}
	goto try_uncompressed
__1:
	;

	// If input is too small, try encoding with LZVN
	if !(src_size < uint64(4096)) {
		goto __2
	}
	// need header + end-of-stream marker
	extra_size = uint64(4) + uint64(unsafe.Sizeof(lzvn_compressed_block_header{}))
	if !(dst_size <= extra_size) {
		goto __3
	}
	goto try_uncompressed
__3:
	; // DST is really too small, give up

	sz = lzvn_encode_buffer(tls,
		dst_buffer+uintptr(uint64(unsafe.Sizeof(lzvn_compressed_block_header{}))),
		dst_size-extra_size, src_buffer, src_size, scratch_buffer)
	if !(sz == uint64(0) || sz >= src_size) {
		goto __4
	}
	goto try_uncompressed
__4:
	;
	(*lzvn_compressed_block_header)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header */)).magic = uint32_t(0x6e787662)
	(*lzvn_compressed_block_header)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header */)).n_raw_bytes = uint32_t(src_size)
	(*lzvn_compressed_block_header)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header */)).n_payload_bytes = uint32_t(sz)
	libc.X__builtin___memcpy_chk(tls, dst_buffer, bp, uint64(unsafe.Sizeof(lzvn_compressed_block_header{})), libc.X__builtin_object_size(tls, dst_buffer, 0))
	store4(tls, dst_buffer+uintptr(uint64(unsafe.Sizeof(lzvn_compressed_block_header{})))+uintptr(sz),
		uint32(0x24787662))

	return sz + extra_size
__2:
	;

	// Try encoding with LZFSE

	state = scratch_buffer
	libc.X__builtin___memset_chk(tls, state, 0x00, uint64(unsafe.Sizeof(lzfse_encoder_state{})), libc.X__builtin_object_size(tls, state, 0))
	if !(lzfse_encode_init(tls, state) != 0) {
		goto __5
	}
	goto try_uncompressed
__5:
	;
	(*lzfse_encoder_state)(unsafe.Pointer(state)).dst = dst_buffer
	(*lzfse_encoder_state)(unsafe.Pointer(state)).dst_begin = dst_buffer
	(*lzfse_encoder_state)(unsafe.Pointer(state)).dst_end = dst_buffer + uintptr(dst_size)
	(*lzfse_encoder_state)(unsafe.Pointer(state)).src = src_buffer
	(*lzfse_encoder_state)(unsafe.Pointer(state)).src_encode_i = int64(0)

	if !(src_size >= uint64(0xffffffff)) {
		goto __6
	}
	//  lzfse only uses 32 bits for offsets internally, so if the input
	//  buffer is really huge, we need to process it in smaller chunks.
	//  Note that we switch over to this path for sizes much smaller
	//  2GB because it's actually faster to change algorithms well before
	//  it's necessary for correctness.
	//  The first chunk, we just process normally.
	encoder_block_size = int64(262144)
	(*lzfse_encoder_state)(unsafe.Pointer(state)).src_end = encoder_block_size
	if !(lzfse_encode_base(tls, state) != 0) {
		goto __8
	}
	goto try_uncompressed
__8:
	;
	src_size = size_t(uint64(src_size) - uint64(encoder_block_size))
__9:
	if !(uint64(src_size) >= uint64(encoder_block_size)) {
		goto __10
	}
	//  All subsequent chunks require a translation to keep the offsets
	//  from getting too big.  Note that we are always going from
	//  encoder_block_size up to 2*encoder_block_size so that the
	//  offsets remain positive (as opposed to resetting to zero and
	//  having negative offsets).
	(*lzfse_encoder_state)(unsafe.Pointer(state)).src_end = int64(2) * encoder_block_size
	if !(lzfse_encode_base(tls, state) != 0) {
		goto __11
	}
	goto try_uncompressed
__11:
	;
	lzfse_encode_translate(tls, state, encoder_block_size)
	src_size = size_t(uint64(src_size) - uint64(encoder_block_size))
	goto __9
__10:
	;
	//  Set the end for the final chunk.
	(*lzfse_encoder_state)(unsafe.Pointer(state)).src_end = encoder_block_size + lzfse_offset(src_size)
	goto __7
__6:
	(*lzfse_encoder_state)(unsafe.Pointer(state)).src_end = lzfse_offset(src_size)
__7:
	;
	//  This is either the trailing chunk (if the source file is huge), or
	//  the whole source file.
	if !(lzfse_encode_base(tls, state) != 0) {
		goto __12
	}
	goto try_uncompressed
__12:
	;
	if !(lzfse_encode_finish(tls, state) != 0) {
		goto __13
	}
	goto try_uncompressed
__13:
	;
	//  No error occured, return compressed size.
	return size_t((int64((**(**lzfse_encoder_state)(unsafe.Pointer(&state))).dst) - int64(dst_buffer)) / 1)

try_uncompressed:
	//  Compression failed for some reason.  If we can fit the data into the
	//  output buffer uncompressed, go ahead and do that instead.
	if !(original_size+uint64(12) <= dst_size && original_size < uint64(2147483647)) {
		goto __14
	}
	**(**uncompressed_block_header)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(12)) /* header1 */) = uncompressed_block_header{magic: uint32_t(0x2d787662), n_raw_bytes: uint32_t(src_size)}
	dst_end = dst_buffer
	libc.X__builtin___memcpy_chk(tls, dst_end, bp+uintptr(12), uint64(unsafe.Sizeof(uncompressed_block_header{})), libc.X__builtin_object_size(tls, dst_end, 0))
	dst_end += uintptr(unsafe.Sizeof(uncompressed_block_header{}))
	libc.X__builtin___memcpy_chk(tls, dst_end, src_buffer, original_size, libc.X__builtin_object_size(tls, dst_end, 0))
	dst_end += uintptr(original_size)
	store4(tls, dst_end, uint32(0x24787662))
	dst_end += uintptr(4)
	return size_t((int64(dst_end) - int64(dst_buffer)) / 1)
__14:
	;

	//  Otherwise, there's nothing we can do, so return zero.
	return uint64(0)
}

func lzfse_encode_buffer(tls *libc.TLS, dst_buffer uintptr, dst_size size_t, src_buffer uintptr, src_size size_t, scratch_buffer uintptr) size_t { /* lzfse_encode.c:143:8: */
	var has_malloc int32 = 0
	var ret size_t = uint64(0)

	// Deal with the possible NULL pointer
	if scratch_buffer == uintptr(0) {
		// +1 in case scratch size could be zero
		scratch_buffer = libc.Xmalloc(tls, lzfse_encode_scratch_size(tls)+uint64(1))
		has_malloc = 1
	}
	if scratch_buffer == uintptr(0) {
		return uint64(0)
	}
	ret = lzfse_encode_buffer_with_scratch(tls, dst_buffer,
		dst_size, src_buffer,
		src_size, scratch_buffer)
	if has_malloc != 0 {
		libc.Xfree(tls, scratch_buffer)
	}
	return ret
}

// MARK: - L, M, D encoding constants for LZFSE

//  Largest encodable L (literal length), M (match length) and D (match
//  distance) values.

// ! @abstract The L, M, D data streams are all encoded as a "base" value, which is
// FSE-encoded, and an "extra bits" value, which is the difference between
// value and base, and is simply represented as a raw bit value (because it
// is the low-order bits of a larger number, not much entropy can be
// extracted from these bits by more complex encoding schemes). The following
// tables represent the number of low-order bits to encode separately and the
// base values for each of L, M, and D.
//
// @note The inverse tables for mapping the other way are significantly larger.
// Those tables have been split out to lzfse_encode_tables.h in order to keep
// this file relatively small.
var l_extra_bits2 = [20]uint8_t{
	uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(2), uint8_t(3), uint8_t(5), uint8_t(8),
} /* lzfse_internal.h:588:22 */
var l_base_value2 = [20]int32_t{
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 28, 60,
} /* lzfse_internal.h:591:22 */
var m_extra_bits2 = [20]uint8_t{
	uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(3), uint8_t(5), uint8_t(8), uint8_t(11),
} /* lzfse_internal.h:594:22 */
var m_base_value2 = [20]int32_t{
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24, 56, 312,
} /* lzfse_internal.h:597:22 */
var d_extra_bits2 = [64]uint8_t{
	uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(1), uint8_t(1), uint8_t(1), uint8_t(1), uint8_t(2), uint8_t(2), uint8_t(2), uint8_t(2), uint8_t(3), uint8_t(3), uint8_t(3), uint8_t(3),
	uint8_t(4), uint8_t(4), uint8_t(4), uint8_t(4), uint8_t(5), uint8_t(5), uint8_t(5), uint8_t(5), uint8_t(6), uint8_t(6), uint8_t(6), uint8_t(6), uint8_t(7), uint8_t(7), uint8_t(7), uint8_t(7),
	uint8_t(8), uint8_t(8), uint8_t(8), uint8_t(8), uint8_t(9), uint8_t(9), uint8_t(9), uint8_t(9), uint8_t(10), uint8_t(10), uint8_t(10), uint8_t(10), uint8_t(11), uint8_t(11), uint8_t(11), uint8_t(11),
	uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(15), uint8_t(15), uint8_t(15), uint8_t(15),
} /* lzfse_internal.h:600:22 */
var d_base_value2 = [64]int32_t{
	0, 1, 2, 3, 4, 6, 8, 10, 12, 16,
	20, 24, 28, 36, 44, 52, 60, 76, 92, 108,
	124, 156, 188, 220, 252, 316, 380, 444, 508, 636,
	764, 892, 1020, 1276, 1532, 1788, 2044, 2556, 3068, 3580,
	4092, 5116, 6140, 7164, 8188, 10236, 12284, 14332, 16380, 20476,
	24572, 28668, 32764, 40956, 49148, 57340, 65532, 81916, 98300, 114684,
	131068, 163836, 196604, 229372,
} /* lzfse_internal.h:606:22 */

// ! @abstract Decode an entry value from next bits of stream.
//  Return \p value, and set \p *nbits to the number of bits to consume
//  (starting with LSB).
func lzfse_decode_v1_freq_value(tls *libc.TLS, bits uint32_t, nbits uintptr) int32 { /* lzfse_decode_base.c:28:19: */

	var b uint32_t = bits & uint32_t(31) // lower 5 bits
	var n int32 = int32(lzfse_freq_nbits_table[b])
	*(*int32)(unsafe.Pointer(nbits)) = n

	// Special cases for > 5 bits encoding
	if n == 8 {
		return int32(uint32_t(8) + bits>>4&uint32_t(0xf))
	}
	if n == 14 {
		return int32(uint32_t(24) + bits>>4&uint32_t(0x3ff))
	}

	// <= 5 bits encoding from table
	return int32(lzfse_freq_value_table[b])
}

var lzfse_freq_nbits_table = [32]int8_t{
	int8(2), int8(3), int8(2), int8(5), int8(2), int8(3), int8(2), int8(8), int8(2), int8(3), int8(2), int8(5), int8(2), int8(3), int8(2), int8(14),
	int8(2), int8(3), int8(2), int8(5), int8(2), int8(3), int8(2), int8(8), int8(2), int8(3), int8(2), int8(5), int8(2), int8(3), int8(2), int8(14)} /* lzfse_decode_base.c:29:23 */
var lzfse_freq_value_table = [32]int8_t{
	int8(0), int8(2), int8(1), int8(4), int8(0), int8(3), int8(1), int8(-1), int8(0), int8(2), int8(1), int8(5), int8(0), int8(3), int8(1), int8(-1),
	int8(0), int8(2), int8(1), int8(6), int8(0), int8(3), int8(1), int8(-1), int8(0), int8(2), int8(1), int8(7), int8(0), int8(3), int8(1), int8(-1)} /* lzfse_decode_base.c:32:23 */

// ! @abstract Extracts up to 32 bits from a 64-bit field beginning at
//  \p offset, and zero-extends them to a \p uint32_t.
//
//  If we number the bits of \p v from 0 (least significant) to 63 (most
//  significant), the result is bits \p offset to \p offset+nbits-1.
func get_field(tls *libc.TLS, v uint64_t, offset int32, nbits int32) uint32_t { /* lzfse_decode_base.c:55:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(offset+nbits < 64 && offset >= 0 && nbits <= 32)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__36)), ts+uintptr(598), 56, ts+uintptr(662))
	} else {
	}
	if nbits == 32 {
		return uint32_t(v >> offset)
	}
	return uint32_t(v >> offset & uint64_t(int32(1)<<nbits-1))
}

var __func__36 = *(*[10]int8)(unsafe.Pointer(ts + uintptr(712))) /* lzfse_decode_base.c:55:69 */

//! @abstract Return \c header_size field from a \c lzfse_compressed_block_header_v2.
func lzfse_decode_v2_header_size(tls *libc.TLS, in uintptr) uint32_t { /* lzfse_decode_base.c:64:1: */
	return get_field(tls, *(*uint64_t)(unsafe.Pointer(in + 8 + 2*8)), 0, 32)
}

// ! @abstract Decode all fields from a \c lzfse_compressed_block_header_v2 to a
// \c lzfse_compressed_block_header_v1.
// @return 0 on success.
// @return -1 on failure.
func lzfse_decode_v1(tls *libc.TLS, out uintptr, in uintptr) int32 { /* lzfse_decode_base.c:72:19: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// Clear all fields
	libc.X__builtin___memset_chk(tls, out, 0x00, uint64(unsafe.Sizeof(lzfse_compressed_block_header_v1{})), libc.X__builtin_object_size(tls, out, 0))

	var v0 uint64_t = *(*uint64_t)(unsafe.Pointer(in + 8))
	var v1 uint64_t = *(*uint64_t)(unsafe.Pointer(in + 8 + 1*8))
	var v2 uint64_t = *(*uint64_t)(unsafe.Pointer(in + 8 + 2*8))

	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).magic = uint32_t(0x31787662)
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).n_raw_bytes = (**(**lzfse_compressed_block_header_v2)(unsafe.Pointer(&in))).n_raw_bytes

	// Literal state
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).n_literals = get_field(tls, v0, 0, 20)
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).n_literal_payload_bytes = get_field(tls, v0, 20, 20)
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).literal_bits = int32(get_field(tls, v0, 60, 3)) - 7
	*(*uint16_t)(unsafe.Pointer(out + 32)) = uint16_t(get_field(tls, v1, 0, 10))
	*(*uint16_t)(unsafe.Pointer(out + 32 + 1*2)) = uint16_t(get_field(tls, v1, 10, 10))
	*(*uint16_t)(unsafe.Pointer(out + 32 + 2*2)) = uint16_t(get_field(tls, v1, 20, 10))
	*(*uint16_t)(unsafe.Pointer(out + 32 + 3*2)) = uint16_t(get_field(tls, v1, 30, 10))

	// L,M,D state
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).n_matches = get_field(tls, v0, 40, 20)
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).n_lmd_payload_bytes = get_field(tls, v1, 40, 20)
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).lmd_bits = int32(get_field(tls, v1, 60, 3)) - 7
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).l_state = uint16_t(get_field(tls, v2, 32, 10))
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).m_state = uint16_t(get_field(tls, v2, 42, 10))
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).d_state = uint16_t(get_field(tls, v2, 52, 10))

	// Total payload size
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(out)).n_payload_bytes = (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&out))).n_literal_payload_bytes + (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&out))).n_lmd_payload_bytes

	// Freq tables
	var dst uintptr = out + 50
	var src uintptr = in + 32
	var src_end uintptr = in + uintptr(get_field(tls, v2, 0, 32)) // first byte after header
	var accum uint32_t = uint32_t(0)
	var accum_nbits int32 = 0

	// No freq tables?
	if src_end == src {
		return 0
	} // OK, freq tables were omitted

	{
		var i int32 = 0
	__1:
		if !(i < 20+20+64+256) {
			goto __3
		}
		{
			// Refill accum, one byte at a time, until we reach end of header, or accum
			// is full
			for src < src_end && accum_nbits+8 <= 32 {
				accum = accum | uint32_t(*(*uint8_t)(unsafe.Pointer(src)))<<accum_nbits
				accum_nbits = accum_nbits + 8
				src++
			}

			// Decode and store value
			**(**int32)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* nbits */) = 0
			*(*uint16_t)(unsafe.Pointer(dst + uintptr(i)*2)) = uint16_t(lzfse_decode_v1_freq_value(tls, accum, bp))

			if int32(**(**int32)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))))) > accum_nbits {
				return -1
			} // failed

			// Consume nbits bits
			accum >>= int32(**(**int32)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* nbits */))
			accum_nbits = accum_nbits - int32(**(**int32)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))))

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	if accum_nbits >= 8 || src != src_end {
		return -1
	} // we need to end up exactly at the end of header, with less than
	// 8 bits in accumulator

	return 0
}

func copy(tls *libc.TLS, dst uintptr, src uintptr, length size_t) { /* lzfse_decode_base.c:147:20: */
	var dst_end uintptr = dst + uintptr(length)
	for __ccgo := true; __ccgo; __ccgo = dst < dst_end {
		copy8(tls, dst, src)
		dst += uintptr(8)
		src += uintptr(8)
	}
}

func lzfse_decode_lmd(tls *libc.TLS, s uintptr) int32 { /* lzfse_decode_base.c:156:12: */
	bp := tls.Alloc(30)
	defer tls.Free(30)

	var bs uintptr
	// var l_state fse_state at bp+uintptr(24), 2

	// var m_state fse_state at bp+uintptr(26), 2

	// var d_state fse_state at bp+uintptr(28), 2

	// var in fse_in_stream at bp, 16

	var src_start uintptr
	// var src uintptr at bp+uintptr(16), 8

	var lit uintptr
	var dst uintptr
	var symbols uint32_t
	var L int32_t
	var M int32_t
	_ = M
	var D int32_t

	//  Number of bytes remaining in the destination buffer, minus 32 to
	//  provide a margin of safety for using overlarge copies on the fast path.
	//  This is a signed quantity, and may go negative when we are close to the
	//  end of the buffer.  That's OK; we're careful about how we handle it
	//  in the slow-and-careful match execution path.
	var remaining_bytes ptrdiff_t
	var i size_t
	var i1 size_t
	var i2 size_t
	var i3 size_t
	var i4 size_t
	var res int32
	var new_d int32_t
	bs = s + 56
	**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(24)) /* l_state */) = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).l_state
	**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(26)) /* m_state */) = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).m_state
	**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(28)) /* d_state */) = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).d_state
	**(**fse_in_stream)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* in */) = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).lmd_in_stream
	src_start = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_begin
	**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(16)) /* src */) = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src + uintptr((**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).lmd_in_buf)
	lit = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).current_literal
	dst = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst
	symbols = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_matches
	L = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).l_value
	M = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).m_value
	D = (**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).d_value

	if libc.X__builtin_expect(tls, libc.BoolInt64(!(int32(fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(24))))) < 64)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__37)), ts+uintptr(598), 171, ts+uintptr(722))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(int32(fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(26))))) < 64)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__37)), ts+uintptr(598), 172, ts+uintptr(754))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(int32(fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(28))))) < 256)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__37)), ts+uintptr(598), 173, ts+uintptr(786))
	} else {
	}
	remaining_bytes = (int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst_end)-int64(dst))/1 - int64(32)

	//  If L or M is non-zero, that means that we have already started decoding
	//  this block, and that we needed to interrupt decoding to get more space
	//  from the caller.  There's a pending L, M, D triplet that we weren't
	//  able to completely process.  Jump ahead to finish executing that symbol
	//  before decoding new values.
	if !(L != 0 || M != 0) {
		goto __1
	}
	goto ExecuteMatch
__1:
	;

__2:
	if !(symbols > uint32_t(0)) {
		goto __3
	}
	//  Decode the next L, M, D symbol from the input stream.
	res = fse_in_checked_flush64(tls, bp, bp+uintptr(16), src_start)
	if !(res != 0) {
		goto __4
	}
	return -3
__4:
	;
	L = fse_value_decode(tls, bp+uintptr(24), bs+60, bp)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(int32(fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(24))))) < 64)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__37)), ts+uintptr(598), 198, ts+uintptr(722))
	} else {
	}
	if !(lit+uintptr(L) >= bs+7228+uintptr(4*10000)+uintptr(64)) {
		goto __5
	}
	return -3
__5:
	;
	res = 0
	if !(res != 0) {
		goto __6
	}
	return -3
__6:
	;
	M = fse_value_decode(tls, bp+uintptr(26), bs+572, bp)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(int32(fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(26))))) < 64)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__37)), ts+uintptr(598), 207, ts+uintptr(754))
	} else {
	}
	res = 0
	if !(res != 0) {
		goto __7
	}
	return -3
__7:
	;
	new_d = fse_value_decode(tls, bp+uintptr(28), bs+1084, bp)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(int32(fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(28))))) < 256)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__37)), ts+uintptr(598), 213, ts+uintptr(786))
	} else {
	}
	if new_d != 0 {
		D = new_d
	} else {
		D = D
	}
	symbols--

ExecuteMatch:
	//  Error if D is out of range, so that we avoid passing through
	//  uninitialized data or accesssing memory out of the destination
	//  buffer.
	if !(int64(uint32_t(D)) > (int64(dst+uintptr(L))-int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst_begin))/1) {
		goto __8
	}
	return -3
__8:
	;

	if !(ptrdiff_t(L+M) <= remaining_bytes) {
		goto __9
	}
	//  If we have plenty of space remaining, we can copy the literal
	//  and match with 16- and 32-byte operations, without worrying
	//  about writing off the end of the buffer.
	remaining_bytes = remaining_bytes - ptrdiff_t(L+M)
	copy(tls, dst, lit, uint64(L))
	dst += uintptr(L)
	lit += uintptr(L)
	//  For the match, we have two paths; a fast copy by 16-bytes if
	//  the match distance is large enough to allow it, and a more
	//  careful path that applies a permutation to account for the
	//  possible overlap between source and destination if the distance
	//  is small.
	if !(D >= 8 || D >= M) {
		goto __11
	}
	copy(tls, dst, dst-uintptr(D), uint64(M))
	goto __12
__11:
	{
		i = uint64(0)
	__13:
		if !(i < size_t(M)) {
			goto __15
		}
		*(*uint8_t)(unsafe.Pointer(dst + uintptr(i))) = *(*uint8_t)(unsafe.Pointer(dst + uintptr(i-size_t(D))))
		goto __14
	__14:
		i++
		goto __13
		goto __15
	__15:
	}
__12:
	;
	dst += uintptr(M)
	goto __10
__9:
	//  Otherwise, we are very close to the end of the destination
	//  buffer, so we cannot use wide copies that slop off the end
	//  of the region that we are copying to. First, we restore
	//  the true length remaining, rather than the sham value we've
	//  been using so far.
	remaining_bytes = remaining_bytes + int64(32)
	//  Now, we process the literal. Either there's space for it
	//  or there isn't; if there is, we copy the whole thing and
	//  update all the pointers and lengths to reflect the copy.
	if !(ptrdiff_t(L) <= remaining_bytes) {
		goto __16
	}
	{
		i1 = uint64(0)
	__18:
		if !(i1 < size_t(L)) {
			goto __20
		}
		*(*uint8_t)(unsafe.Pointer(dst + uintptr(i1))) = *(*uint8_t)(unsafe.Pointer(lit + uintptr(i1)))
		goto __19
	__19:
		i1++
		goto __18
		goto __20
	__20:
	}
	dst += uintptr(L)
	lit += uintptr(L)
	remaining_bytes = remaining_bytes - ptrdiff_t(L)
	L = 0
	goto __17
__16:
	{
		i2 = uint64(0)
	__21:
		if !(i2 < size_t(remaining_bytes)) {
			goto __23
		}
		*(*uint8_t)(unsafe.Pointer(dst + uintptr(i2))) = *(*uint8_t)(unsafe.Pointer(lit + uintptr(i2)))
		goto __22
	__22:
		i2++
		goto __21
		goto __23
	__23:
	}
	dst += uintptr(remaining_bytes)
	lit += uintptr(remaining_bytes)
	L = int32_t(ptrdiff_t(L) - remaining_bytes)
	goto DestinationBufferIsFull
__17:
	;
	//  The match goes just like the literal does. We copy as much as
	//  we can byte-by-byte, and if we reach the end of the buffer
	//  before finishing, we return to the caller indicating that
	//  the buffer is full.
	if !(ptrdiff_t(M) <= remaining_bytes) {
		goto __24
	}
	{
		i3 = uint64(0)
	__26:
		if !(i3 < size_t(M)) {
			goto __28
		}
		*(*uint8_t)(unsafe.Pointer(dst + uintptr(i3))) = *(*uint8_t)(unsafe.Pointer(dst + uintptr(i3-size_t(D))))
		goto __27
	__27:
		i3++
		goto __26
		goto __28
	__28:
	}
	dst += uintptr(M)
	remaining_bytes = remaining_bytes - ptrdiff_t(M)
	M = 0
	_ = M // no dead store warning
	//  We don't need to update M = 0, because there's no partial
	//  symbol to continue executing. Either we're at the end of
	//  the block, in which case we will never need to resume with
	//  this state, or we're going to decode another L, M, D set,
	//  which will overwrite M anyway.
	//
	// But we still set M = 0, to maintain the post-condition.
	goto __25
__24:
	{
		i4 = uint64(0)
	__29:
		if !(i4 < size_t(remaining_bytes)) {
			goto __31
		}
		*(*uint8_t)(unsafe.Pointer(dst + uintptr(i4))) = *(*uint8_t)(unsafe.Pointer(dst + uintptr(i4-size_t(D))))
		goto __30
	__30:
		i4++
		goto __29
		goto __31
	__31:
	}
	dst += uintptr(remaining_bytes)
	M = int32_t(ptrdiff_t(M) - remaining_bytes)
DestinationBufferIsFull:
	//  Because we want to be able to resume decoding where we've left
	//  off (even in the middle of a literal or match), we need to
	//  update all of the block state fields with the current values
	//  so that we can resume execution from this point once the
	//  caller has given us more space to write into.
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).l_value = L
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).m_value = M
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).d_value = D
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).l_state = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(24)) /* l_state */))
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).m_state = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(26)) /* m_state */))
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).d_state = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(28)) /* d_state */))
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).lmd_in_stream = fse_in_stream(**(**fse_in_stream)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* in */))
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).n_matches = symbols
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).lmd_in_buf = uint32_t((int64(uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(16))))) - int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src)) / 1)
	(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).current_literal = lit
	(*lzfse_decoder_state)(unsafe.Pointer(s)).dst = dst
	return -2
__25:
	;
	//  Restore the "sham" decremented value of remaining_bytes and
	//  continue to the next L, M, D triple. We'll just be back in
	//  the careful path again, but this only happens at the very end
	//  of the buffer, so a little minor inefficiency here is a good
	//  tradeoff for simpler code.
	remaining_bytes = remaining_bytes - int64(32)
__10:
	;
	goto __2
__3:
	;
	//  Because we've finished with the whole block, we don't need to update
	//  any of the blockstate fields; they will not be used again. We just
	//  update the destination pointer in the state object and return.
	(*lzfse_decoder_state)(unsafe.Pointer(s)).dst = dst
	return 0
}

var __func__37 = *(*[17]int8)(unsafe.Pointer(ts + uintptr(818))) /* lzfse_decode_base.c:156:53 */

func lzfse_decode(tls *libc.TLS, s uintptr) int32 { /* lzfse_decode_base.c:332:5: */
	bp := tls.Alloc(920)
	defer tls.Free(920)

	for 1 != 0 {
		// Are we inside a block?
		switch (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).block_magic {
		case uint32_t(0x00000000):
			{
				// We need at least 4 bytes of magic number to identify next block
				if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(4) > (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end {
					return -1
				} // SRC truncated
				var magic uint32_t = load4(tls, (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src)

				if magic == uint32_t(0x24787662) {
					**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr(4)
					(*lzfse_decoder_state)(unsafe.Pointer(s)).end_of_stream = 1
					return 0 // done
				}

				if magic == uint32_t(0x2d787662) {
					if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(uint64(unsafe.Sizeof(uncompressed_block_header{}))) > (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end {
						return -1
					} // SRC truncated
					// Setup state for uncompressed block
					var bs uintptr = s + 47364
					(*uncompressed_block_decoder_state)(unsafe.Pointer(bs)).n_raw_bytes = load4(tls, (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(uint64(uintptr(0)+4)))
					**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr(unsafe.Sizeof(uncompressed_block_header{}))
					(*lzfse_decoder_state)(unsafe.Pointer(s)).block_magic = magic
					break
				}

				if magic == uint32_t(0x6e787662) {
					if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(uint64(unsafe.Sizeof(lzvn_compressed_block_header{}))) > (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end {
						return -1
					} // SRC truncated
					// Setup state for compressed LZVN block
					var bs uintptr = s + 47352
					(*lzvn_compressed_block_decoder_state)(unsafe.Pointer(bs)).n_raw_bytes = load4(tls, (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(uint64(uintptr(0)+4)))
					(*lzvn_compressed_block_decoder_state)(unsafe.Pointer(bs)).n_payload_bytes = load4(tls,
						(**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(uint64(uintptr(0)+8)))
					(*lzvn_compressed_block_decoder_state)(unsafe.Pointer(bs)).d_prev = uint32_t(0)
					**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr(unsafe.Sizeof(lzvn_compressed_block_header{}))
					(*lzfse_decoder_state)(unsafe.Pointer(s)).block_magic = magic
					break
				}

				if magic == uint32_t(0x31787662) || magic == uint32_t(0x32787662) {
					// var header1 lzfse_compressed_block_header_v1 at bp, 772

					var header_size size_t = uint64(0)

					// Decode compressed headers
					if magic == uint32_t(0x32787662) {
						// Check we have the fixed part of the structure
						if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(uint64(uintptr(0)+32)) > (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end {
							return -1
						} // SRC truncated

						// Get size, and check we have the entire structure
						var header2 uintptr = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src // not aligned, OK
						header_size = size_t(lzfse_decode_v2_header_size(tls, header2))
						if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(header_size) > (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end {
							return -1
						} // SRC truncated
						var decodeStatus int32 = lzfse_decode_v1(tls, bp, header2)
						if decodeStatus != 0 {
							return -3
						} // failed
					} else {
						if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(uint64(unsafe.Sizeof(lzfse_compressed_block_header_v1{}))) > (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end {
							return -1
						} // SRC truncated
						libc.X__builtin___memcpy_chk(tls, bp, (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src, uint64(unsafe.Sizeof(lzfse_compressed_block_header_v1{})), libc.X__builtin_object_size(tls, bp, 0))
						header_size = size_t(unsafe.Sizeof(lzfse_compressed_block_header_v1{}))
					}

					// We require the header + entire encoded block to be present in SRC
					// during the entire block decoding.
					// This can be relaxed somehow, if it becomes a limiting factor, at the
					// price of a more complex state maintenance.
					// For DST, we can't easily require space for the entire decoded block,
					// because it may expand to something very very large.
					if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src+uintptr(header_size)+uintptr((*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).n_literal_payload_bytes)+uintptr((*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).n_lmd_payload_bytes) > (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end {
						return -1
					} // need all encoded block

					// Sanity checks
					if lzfse_check_block_header_v1(tls, bp) != 0 {
						return -3
					}

					// Skip header
					**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr(header_size)

					// Setup state for compressed V1 block from header
					var bs uintptr = s + 56
					(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).n_lmd_payload_bytes = (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header1 */)).n_lmd_payload_bytes
					(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).n_matches = (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header1 */)).n_matches
					fse_init_decoder_table(tls, 1024,
						256,
						bp+258, bs+3132)
					fse_init_value_decoder_table(tls,
						64, 20, bp+50,
						uintptr(unsafe.Pointer(&l_extra_bits2)), uintptr(unsafe.Pointer(&l_base_value2)), bs+60)
					fse_init_value_decoder_table(tls,
						64, 20, bp+90,
						uintptr(unsafe.Pointer(&m_extra_bits2)), uintptr(unsafe.Pointer(&m_base_value2)), bs+572)
					fse_init_value_decoder_table(tls,
						256, 64, bp+130,
						uintptr(unsafe.Pointer(&d_extra_bits2)), uintptr(unsafe.Pointer(&d_base_value2)), bs+1084)

					// Decode literals
					{
						// var in fse_in_stream at bp+uintptr(776), 16

						var buf_start uintptr = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_begin
						**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr((*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).n_literal_payload_bytes) // skip literal payload
						**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(792)) /* buf */) = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src                      // read bits backwards from the end
						if fse_in_checked_init64(tls, bp+uintptr(776), (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).literal_bits, bp+uintptr(792), buf_start) != 0 {
							return -3
						}

						**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(800)) /* state0 */) = *(*uint16_t)(unsafe.Pointer(bp + 32))
						**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(802)) /* state1 */) = *(*uint16_t)(unsafe.Pointer(bp + 32 + 1*2))
						**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(804)) /* state2 */) = *(*uint16_t)(unsafe.Pointer(bp + 32 + 2*2))
						**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(806)) /* state3 */) = *(*uint16_t)(unsafe.Pointer(bp + 32 + 3*2))

						{
							var i uint32_t = uint32_t(0)
						__1:
							if !(i < (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).n_literals) {
								goto __3
							} // n_literals is multiple of 4
							{
								if fse_in_checked_flush64(tls, bp+uintptr(776), bp+uintptr(792), buf_start) != 0 {
									return -3
								} // [57, 64] bits
								*(*uint8_t)(unsafe.Pointer(bs + 7228 + uintptr(i+uint32_t(0)))) = fse_decode(tls, bp+uintptr(800), bs+3132, bp+uintptr(776))           // 10b max
								*(*uint8_t)(unsafe.Pointer(bs + 7228 + uintptr(i+uint32_t(1)))) = fse_decode(tls, bp+uintptr(802), bs+3132, bp+uintptr(776))           // 10b max
								*(*uint8_t)(unsafe.Pointer(bs + 7228 + uintptr(i+uint32_t(2)))) = fse_decode(tls, bp+uintptr(804), bs+3132, bp+uintptr(776))           // 10b max
								*(*uint8_t)(unsafe.Pointer(bs + 7228 + uintptr(i+uint32_t(3)))) = fse_decode(tls, bp+uintptr(806), bs+3132, bp+uintptr(776) /* &in */) // 10b max

							}
							goto __2
						__2:
							i = i + uint32_t(4)
							goto __1
							goto __3
						__3:
						}

						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).current_literal = bs + 7228 /* &.literals */

					} // literals

					// SRC is not incremented to skip the LMD payload, since we need it
					// during block decode.
					// We will increment SRC at the end of the block only after this point.

					// Initialize the L,M,D decode stream, do not start decoding matches
					// yet, and store decoder state
					{
						// var in fse_in_stream at bp+uintptr(808), 16

						// read bits backwards from the end
						**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(824)) /* buf */) = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src + uintptr((*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).n_lmd_payload_bytes)
						if fse_in_checked_init64(tls, bp+uintptr(808), (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).lmd_bits, bp+uintptr(824), (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src) != 0 {
							return -3
						}

						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs)).l_state = (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header1 */)).l_state
						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).m_state = (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header1 */)).m_state
						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).d_state = (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &header1 */)).d_state
						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).lmd_in_buf = uint32_t((int64(uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(824))))) - int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src)) / 1)
						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).l_value = libc.AssignPtrInt32(bs+20, 0)
						//  Initialize D to an illegal value so we can't erroneously use
						//  an uninitialized "previous" value.
						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).d_value = -1
						(*lzfse_compressed_block_decoder_state)(unsafe.Pointer(bs)).lmd_in_stream = fse_in_stream(**(**fse_in_stream)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(808)) /* in */))

					}

					(*lzfse_decoder_state)(unsafe.Pointer(s)).block_magic = magic
					break
				}

				// Here we have an invalid magic number
				return -3

			} // LZFSE_NO_BLOCK_MAGIC

		case uint32_t(0x2d787662):
			{
				var bs uintptr = s + 47364

				//  Compute the size (in bytes) of the data that we will actually copy.
				//  This size is minimum(bs->n_raw_bytes, space in src, space in dst).

				var copy_size uint32_t = (**(**uncompressed_block_decoder_state)(unsafe.Pointer(&bs))).n_raw_bytes // bytes left to copy
				if copy_size == uint32_t(0) {
					(*lzfse_decoder_state)(unsafe.Pointer(s)).block_magic = uint32_t(0)
					break
				} // end of block

				if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end <= (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src {
					return -1
				} // need more SRC data
				var src_space size_t = size_t((int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end) - int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src)) / 1)
				if size_t(copy_size) > src_space {
					copy_size = uint32_t(src_space)
				} // limit to SRC data (> 0)

				if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst_end <= (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst {
					return -2
				} // need more DST capacity
				var dst_space size_t = size_t((int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst_end) - int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst)) / 1)
				if size_t(copy_size) > dst_space {
					copy_size = uint32_t(dst_space)
				} // limit to DST capacity (> 0)

				// Now that we know that the copy size is bounded to the source and
				// dest buffers, go ahead and copy the data.
				// We always have copy_size > 0 here
				libc.X__builtin___memcpy_chk(tls, (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst, (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src, uint64(copy_size), libc.X__builtin_object_size(tls, (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst, 0))
				**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr(copy_size)
				**(**uintptr)(unsafe.Pointer(uintptr(s + 24))) += uintptr(copy_size)
				*(*uint32_t)(unsafe.Pointer(bs)) -= copy_size

				break

			} // LZFSE_UNCOMPRESSED_BLOCK_MAGIC

		case uint32_t(0x31787662):
			fallthrough
		case uint32_t(0x32787662):
			{
				var bs uintptr = s + 56
				// Require the entire LMD payload to be in SRC
				if (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end <= (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src || size_t((**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_lmd_payload_bytes) > size_t((int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end)-int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src))/1) {
					return -1
				}

				var status int32 = lzfse_decode_lmd(tls, s)
				if status != 0 {
					return status
				}

				(*lzfse_decoder_state)(unsafe.Pointer(s)).block_magic = uint32_t(0x00000000)
				**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr((**(**lzfse_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_lmd_payload_bytes) // to next block
				break

			} // LZFSE_COMPRESSEDV1_BLOCK_MAGIC || LZFSE_COMPRESSEDV2_BLOCK_MAGIC

		case uint32_t(0x6e787662):
			{
				var bs uintptr = s + 47352
				if (**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_payload_bytes > uint32_t(0) && (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end <= (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src {
					return -1
				} // need more SRC data

				// Init LZVN decoder state
				// var dstate lzvn_decoder_state at bp+uintptr(832), 88

				libc.X__builtin___memset_chk(tls, bp+uintptr(832), 0x00, uint64(unsafe.Sizeof(lzvn_decoder_state{})), libc.X__builtin_object_size(tls, bp+uintptr(832), 0))
				(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).src = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src
				(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).src_end = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src_end
				if (int64((*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(832))).src_end)-int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src))/1 > int64((**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_payload_bytes) {
					(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).src_end = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src + uintptr((**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_payload_bytes)
				} // limit to payload bytes
				(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).dst_begin = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst_begin
				(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).dst = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst
				(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).dst_end = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst_end
				if (int64((*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(832))).dst_end)-int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst))/1 > int64((**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_raw_bytes) {
					(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).dst_end = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst + uintptr((**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_raw_bytes)
				} // limit to raw bytes
				(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).d_prev = lzvn_offset((**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).d_prev)
				(*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).end_of_stream = 0

				// Run LZVN decoder
				lzvn_decode(tls, bp+uintptr(832))

				// Update our state
				var src_used size_t = size_t((int64((*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(832))).src) - int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src)) / 1)
				var dst_used size_t = size_t((int64((*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(832))).dst) - int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst)) / 1)
				if src_used > size_t((**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_payload_bytes) || dst_used > size_t((**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_raw_bytes) {
					return -3
				} // sanity check
				(*lzfse_decoder_state)(unsafe.Pointer(s)).src = (*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).src
				(*lzfse_decoder_state)(unsafe.Pointer(s)).dst = (*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).dst
				*(*uint32_t)(unsafe.Pointer(bs + 4)) -= uint32_t(src_used)
				*(*uint32_t)(unsafe.Pointer(bs)) -= uint32_t(dst_used)
				(*lzvn_compressed_block_decoder_state)(unsafe.Pointer(bs)).d_prev = uint32_t((*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(832) /* &dstate */)).d_prev)

				// Test end of block
				if (**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_payload_bytes == uint32_t(0) && (**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_raw_bytes == uint32_t(0) && (*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(832))).end_of_stream != 0 {
					(*lzfse_decoder_state)(unsafe.Pointer(s)).block_magic = uint32_t(0)
					break
				} // block done

				// Check for invalid state
				if (**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_payload_bytes == uint32_t(0) || (**(**lzvn_compressed_block_decoder_state)(unsafe.Pointer(&bs))).n_raw_bytes == uint32_t(0) || (*lzvn_decoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(832))).end_of_stream != 0 {
					return -3
				}

				// Here, block is not done and state is valid, so we need more space in dst.
				return -2

			}

		default:
			return -3 // invalid magic

		} // switch magic

	} // block loop

	return 0
}

func lzfse_decode_scratch_size(tls *libc.TLS) size_t { /* lzfse_decode.c:27:8: */
	return size_t(unsafe.Sizeof(lzfse_decoder_state{}))
}

func lzfse_decode_buffer_with_scratch(tls *libc.TLS, dst_buffer uintptr, dst_size size_t, src_buffer uintptr, src_size size_t, scratch_buffer uintptr) size_t { /* lzfse_decode.c:29:8: */
	var s uintptr = scratch_buffer
	libc.X__builtin___memset_chk(tls, s, 0x00, uint64(unsafe.Sizeof(lzfse_decoder_state{})), libc.X__builtin_object_size(tls, s, 0))

	// Initialize state
	(*lzfse_decoder_state)(unsafe.Pointer(s)).src = src_buffer
	(*lzfse_decoder_state)(unsafe.Pointer(s)).src_begin = src_buffer
	(*lzfse_decoder_state)(unsafe.Pointer(s)).src_end = (**(**lzfse_decoder_state)(unsafe.Pointer(&s))).src + uintptr(src_size)
	(*lzfse_decoder_state)(unsafe.Pointer(s)).dst = dst_buffer
	(*lzfse_decoder_state)(unsafe.Pointer(s)).dst_begin = dst_buffer
	(*lzfse_decoder_state)(unsafe.Pointer(s)).dst_end = dst_buffer + uintptr(dst_size)

	// Decode
	var status int32 = lzfse_decode(tls, s)
	if status == -2 {
		return dst_size
	}
	if status != 0 {
		return uint64(0)
	} // failed
	return size_t((int64((**(**lzfse_decoder_state)(unsafe.Pointer(&s))).dst) - int64(dst_buffer)) / 1) // bytes written
}

func lzfse_decode_buffer(tls *libc.TLS, dst_buffer uintptr, dst_size size_t, src_buffer uintptr, src_size size_t, scratch_buffer uintptr) size_t { /* lzfse_decode.c:52:8: */
	var has_malloc int32 = 0
	var ret size_t = uint64(0)

	// Deal with the possible NULL pointer
	if scratch_buffer == uintptr(0) {
		// +1 in case scratch size could be zero
		scratch_buffer = libc.Xmalloc(tls, lzfse_decode_scratch_size(tls)+uint64(1))
		has_malloc = 1
	}
	if scratch_buffer == uintptr(0) {
		return uint64(0)
	}
	ret = lzfse_decode_buffer_with_scratch(tls, dst_buffer,
		dst_size, src_buffer,
		src_size, scratch_buffer)
	if has_malloc != 0 {
		libc.Xfree(tls, scratch_buffer)
	}
	return ret
}

// Initialize encoder table T[NSYMBOLS].
// NSTATES = sum FREQ[i] is the number of states (a power of 2)
// NSYMBOLS is the number of symbols.
// FREQ[NSYMBOLS] is a normalized histogram of symbol frequencies, with FREQ[i]
// >= 0.
// Some symbols may have a 0 frequency.  In that case, they should not be
// present in the data.
func fse_init_encoder_table(tls *libc.TLS, nstates int32, nsymbols int32, freq uintptr, t uintptr) { /* lzfse_fse.c:31:6: */
	var offset int32 = 0 // current offset
	var n_clz int32 = libc.X__builtin_clz(tls, uint32(nstates))
	{
		var i int32 = 0
	__1:
		if !(i < nsymbols) {
			goto __3
		}
		{
			var f int32 = int32(*(*uint16_t)(unsafe.Pointer(freq + uintptr(i)*2)))
			if f == 0 {
				goto __2
			} // skip this symbol, no occurrences
			var k int32 = libc.X__builtin_clz(tls, uint32(f)) - n_clz // shift needed to ensure N <= (F<<K) < 2*N
			(*fse_encoder_entry)(unsafe.Pointer(t + uintptr(i)*8)).s0 = int16_t(f<<k - nstates)
			(*fse_encoder_entry)(unsafe.Pointer(t + uintptr(i)*8)).k = int16_t(k)
			(*fse_encoder_entry)(unsafe.Pointer(t + uintptr(i)*8)).delta0 = int16_t(offset - f + nstates>>k)
			(*fse_encoder_entry)(unsafe.Pointer(t + uintptr(i)*8)).delta1 = int16_t(offset - f + nstates>>(k-1))
			offset = offset + f

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
}

// Initialize decoder table T[NSTATES].
// NSTATES = sum FREQ[i] is the number of states (a power of 2)
// NSYMBOLS is the number of symbols.
// FREQ[NSYMBOLS] is a normalized histogram of symbol frequencies, with FREQ[i]
// >= 0.
// Some symbols may have a 0 frequency.  In that case, they should not be
// present in the data.
func fse_init_decoder_table(tls *libc.TLS, nstates int32, nsymbols int32, freq uintptr, t uintptr) int32 { /* lzfse_fse.c:57:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if libc.X__builtin_expect(tls, libc.BoolInt64(!(nsymbols <= 256)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__62)), ts+uintptr(835), 60, ts+uintptr(891))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(fse_check_freq(tls, freq, uint64(nsymbols), uint64(nstates)) == 0)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__62)), ts+uintptr(835), 61, ts+uintptr(907))
	} else {
	}
	var n_clz int32 = libc.X__builtin_clz(tls, uint32(nstates))
	var sum_of_freq int32 = 0
	{
		var i int32 = 0
	__1:
		if !(i < nsymbols) {
			goto __3
		}
		{
			var f int32 = int32(*(*uint16_t)(unsafe.Pointer(freq + uintptr(i)*2)))
			if f == 0 {
				goto __2
			} // skip this symbol, no occurrences

			sum_of_freq = sum_of_freq + f

			if sum_of_freq > nstates {
				return -1
			}

			var k int32 = libc.X__builtin_clz(tls, uint32(f)) - n_clz // shift needed to ensure N <= (F<<K) < 2*N
			var j0 int32 = 2*nstates>>k - f

			// Initialize all states S reached by this symbol: OFFSET <= S < OFFSET + F
			{
				var j int32 = 0
			__4:
				if !(j < f) {
					goto __6
				}
				{
					// var e fse_decoder_entry at bp, 4

					(*fse_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).symbol = uint8_t(i)
					if j < j0 {
						(*fse_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).k = int8_t(k)
						(*fse_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).delta = int16_t((f+j)<<k - nstates)
					} else {
						(*fse_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).k = int8_t(k - 1)
						(*fse_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).delta = int16_t((j - j0) << (k - 1))
					}

					libc.X__builtin___memcpy_chk(tls, t, bp, uint64(unsafe.Sizeof(fse_decoder_entry{})), libc.X__builtin_object_size(tls, t, 0))
					t += 4

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	return 0 // OK
}

var __func__62 = *(*[23]int8)(unsafe.Pointer(ts + uintptr(952))) /* lzfse_fse.c:59:51 */

// Initialize value decoder table T[NSTATES].
// NSTATES = sum FREQ[i] is the number of states (a power of 2)
// NSYMBOLS is the number of symbols.
// FREQ[NSYMBOLS] is a normalized histogram of symbol frequencies, with FREQ[i]
// >= 0.
// SYMBOL_VBITS[NSYMBOLS] and SYMBOLS_VBASE[NSYMBOLS] are the number of value
// bits to read and the base value for each symbol.
// Some symbols may have a 0 frequency.  In that case, they should not be
// present in the data.
func fse_init_value_decoder_table(tls *libc.TLS, nstates int32, nsymbols int32, freq uintptr, symbol_vbits uintptr, symbol_vbase uintptr, t uintptr) { /* lzfse_fse.c:109:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if libc.X__builtin_expect(tls, libc.BoolInt64(!(nsymbols <= 256)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__63)), ts+uintptr(835), 114, ts+uintptr(891))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(fse_check_freq(tls, freq, uint64(nsymbols), uint64(nstates)) == 0)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__63)), ts+uintptr(835), 115, ts+uintptr(907))
	} else {
	}

	var n_clz int32 = libc.X__builtin_clz(tls, uint32(nstates))
	{
		var i int32 = 0
	__1:
		if !(i < nsymbols) {
			goto __3
		}
		{
			var f int32 = int32(*(*uint16_t)(unsafe.Pointer(freq + uintptr(i)*2)))
			if f == 0 {
				goto __2
			} // skip this symbol, no occurrences

			var k int32 = libc.X__builtin_clz(tls, uint32(f)) - n_clz // shift needed to ensure N <= (F<<K) < 2*N
			var j0 int32 = 2*nstates>>k - f

			var ei = fse_value_decoder_entry{}
			ei.value_bits = *(*uint8_t)(unsafe.Pointer(symbol_vbits + uintptr(i)))
			ei.vbase = *(*int32_t)(unsafe.Pointer(symbol_vbase + uintptr(i)*4))

			// Initialize all states S reached by this symbol: OFFSET <= S < OFFSET + F
			{
				var j int32 = 0
			__4:
				if !(j < f) {
					goto __6
				}
				{
					**(**fse_value_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* e */) = ei

					if j < j0 {
						(*fse_value_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).total_bits = uint8_t(int32(uint8_t(k)) + int32((*fse_value_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).value_bits))
						(*fse_value_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).delta = int16_t((f+j)<<k - nstates)
					} else {
						(*fse_value_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).total_bits = uint8_t(int32(uint8_t(k-1)) + int32((*fse_value_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).value_bits))
						(*fse_value_decoder_entry)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &e */)).delta = int16_t((j - j0) << (k - 1))
					}

					libc.X__builtin___memcpy_chk(tls, t, bp, uint64(8), libc.X__builtin_object_size(tls, t, 0))
					t += 8

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
}

var __func__63 = *(*[29]int8)(unsafe.Pointer(ts + uintptr(975))) /* lzfse_fse.c:113:74 */

// Remove states from symbols until the correct number of states is used.
func fse_adjust_freqs(tls *libc.TLS, freq uintptr, overrun int32, nsymbols int32) { /* lzfse_fse.c:150:13: */
	{
		var shift int32 = 3
	__1:
		if !(overrun != 0) {
			goto __3
		}
		{
			{
				var sym int32 = 0
			__4:
				if !(sym < nsymbols) {
					goto __6
				}
				{
					if int32(*(*uint16_t)(unsafe.Pointer(freq + uintptr(sym)*2))) > 1 {
						var n int32 = (int32(*(*uint16_t)(unsafe.Pointer(freq + uintptr(sym)*2))) - 1) >> shift
						if n > overrun {
							n = overrun
						}
						*(*uint16_t)(unsafe.Pointer(freq + uintptr(sym)*2)) -= uint16_t(n)
						overrun = overrun - n
						if overrun == 0 {
							goto __6
						}
					}

				}
				goto __5
			__5:
				sym++
				goto __4
				goto __6
			__6:
			}

		}
		goto __2
	__2:
		shift--
		goto __1
		goto __3
	__3:
	}
}

// Normalize a table T[NSYMBOLS] of occurrences to FREQ[NSYMBOLS].
func fse_normalize_freq(tls *libc.TLS, nstates int32, nsymbols int32, t uintptr, freq uintptr) { /* lzfse_fse.c:167:6: */
	var s_count uint32_t = uint32_t(0)
	var remaining int32 = nstates // must be signed; this may become < 0
	var max_freq int32 = 0
	var max_freq_sym int32 = 0
	var shift int32 = libc.X__builtin_clz(tls, uint32(nstates)) - 1
	var highprec_step uint32_t

	// Compute the total number of symbol occurrences
	{
		var i int32 = 0
	__1:
		if !(i < nsymbols) {
			goto __3
		}
		s_count = s_count + *(*uint32_t)(unsafe.Pointer(t + uintptr(i)*4))
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	if s_count == uint32_t(0) {
		highprec_step = uint32_t(0)
	} else {
		highprec_step = uint32_t(uint32_t(1)) << 31 / s_count
	}

	{
		var i1 int32 = 0
	__4:
		if !(i1 < nsymbols) {
			goto __6
		}
		{

			// Rescale the occurrence count to get the normalized frequency.
			// Round up if the fractional part is >= 0.5; otherwise round down.
			// For efficiency, we do this calculation using integer arithmetic.
			var f int32 = int32((*(*uint32_t)(unsafe.Pointer(t + uintptr(i1)*4))*highprec_step>>shift + uint32_t(1)) >> 1)

			// If a symbol was used, it must be given a nonzero normalized frequency.
			if f == 0 && *(*uint32_t)(unsafe.Pointer(t + uintptr(i1)*4)) != uint32_t(0) {
				f = 1
			}

			*(*uint16_t)(unsafe.Pointer(freq + uintptr(i1)*2)) = uint16_t(f)
			remaining = remaining - f

			// Remember the maximum frequency and which symbol had it.
			if f > max_freq {
				max_freq = f
				max_freq_sym = i1
			}

		}
		goto __5
	__5:
		i1++
		goto __4
		goto __6
	__6:
	}

	// If there remain states to be assigned, then just assign them to the most
	// frequent symbol.  Alternatively, if we assigned more states than were
	// actually available, then either remove states from the most frequent symbol
	// (for minor overruns) or use the slower adjustment algorithm (for major
	// overruns).
	if -remaining < max_freq>>2 {
		*(*uint16_t)(unsafe.Pointer(freq + uintptr(max_freq_sym)*2)) += uint16_t(remaining)
	} else {
		fse_adjust_freqs(tls, freq, -remaining, nsymbols)
	}
}

// ===============================================================
// Types and Constants

// 0xFFFF
// MUST be >= 8
// literal, MUST be >= 271

//! @abstract Type of table entry.
type lzvn_encode_entry_type = struct {
	indices [4]int32_t
	values  [4]uint32_t
} /* lzvn_encode_base.h:52:3 */

// Work size

//! @abstract Match
type lzvn_match_info = struct {
	m_begin lzvn_offset
	m_end   lzvn_offset
	M       lzvn_offset
	D       lzvn_offset
	K       lzvn_offset
} /* lzvn_encode_base.h:66:3 */

// ===============================================================
// Internal encoder state

//! @abstract Base encoder state and I/O.
type lzvn_encoder_state = struct {
	src             uintptr
	src_begin       lzvn_offset
	src_end         lzvn_offset
	src_current     lzvn_offset
	src_current_end lzvn_offset
	src_literal     lzvn_offset
	dst             uintptr
	dst_begin       uintptr
	dst_end         uintptr
	pending         lzvn_match_info
	d_prev          lzvn_offset
	table           uintptr
} /* lzvn_encode_base.h:109:3 */

// ===============================================================
// Coarse/fine copy, non overlapping buffers

// ! @abstract Copy at least \p nbytes bytes from \p src to \p dst, by blocks
// of 8 bytes (may go beyond range). No overlap.
// @return \p dst + \p nbytes.
func lzvn_copy64(tls *libc.TLS, dst uintptr, src uintptr, nbytes size_t) uintptr { /* lzvn_encode_base.c:36:29: */
	{
		var i size_t = uint64(0)
	__1:
		if !(i < nbytes) {
			goto __3
		}
		store8(tls, dst+uintptr(i), load8(tls, src+uintptr(i)))
		goto __2
	__2:
		i = i + uint64(8)
		goto __1
		goto __3
	__3:
	}
	return dst + uintptr(nbytes)
}

// ! @abstract Copy exactly \p nbytes bytes from \p src to \p dst (respects range).
// No overlap.
// @return \p dst + \p nbytes.
func lzvn_copy8(tls *libc.TLS, dst uintptr, src uintptr, nbytes size_t) uintptr { /* lzvn_encode_base.c:47:29: */
	{
		var i size_t = uint64(0)
	__1:
		if !(i < nbytes) {
			goto __3
		}
		*(*uint8)(unsafe.Pointer(dst + uintptr(i))) = *(*uint8)(unsafe.Pointer(src + uintptr(i)))
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	return dst + uintptr(nbytes)
}

// ! @abstract Emit (L,0,0) instructions (final literal).
// We read at most \p L bytes from \p p.
// @param p input stream
// @param q1 the first byte after the output buffer.
// @return pointer to the next output, <= \p q1.
// @return \p q1 if output is full. In that case, output will be partially invalid.
func emit_literal(tls *libc.TLS, p uintptr, q uintptr, q1 uintptr, L size_t) uintptr { /* lzvn_encode_base.c:62:29: */
	var x size_t
__1:
	if !(L > uint64(15)) {
		goto __2
	}
	if L < uint64(271) {
		x = L
	} else {
		x = uint64(271)
	}
	if !(q+uintptr(x)+uintptr(10) >= q1) {
		goto __3
	}
	goto OUT_FULL
__3:
	;
	store2(tls, q, uint16(uint64(0xE0)+(x-uint64(16))<<8))
	q += uintptr(2)
	L = L - x
	q = lzvn_copy8(tls, q, p, x)
	p += uintptr(x)
	goto __1
__2:
	;
	if !(L > uint64(0)) {
		goto __4
	}
	if !(q+uintptr(L)+uintptr(10) >= q1) {
		goto __5
	}
	goto OUT_FULL
__5:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(uint64(0xE0) + L) // 1110LLLL
	q = lzvn_copy8(tls, q, p, L)
__4:
	;
	return q

OUT_FULL:
	return q1
}

// ! @abstract Emit (L,M,D) instructions. M>=3.
// @param p input stream pointing to the beginning of the literal. We read at
// most \p L+4 bytes from \p p.
// @param q1 the first byte after the output buffer.
// @return pointer to the next output, <= \p q1.
// @return \p q1 if output is full. In that case, output will be partially invalid.
func emit(tls *libc.TLS, p uintptr, q uintptr, q1 uintptr, L size_t, M size_t, D size_t, D_prev size_t) uintptr { /* lzvn_encode_base.c:95:29: */
	var x size_t // M = (x+3) + M'    max value for x is 7-2*L

	// Here L<4 literals remaining, we read them here
	var literal uint32_t
__1:
	if !(L > uint64(15)) {
		goto __2
	}
	if L < uint64(271) {
		x = L
	} else {
		x = uint64(271)
	}
	if !(q+uintptr(x)+uintptr(10) >= q1) {
		goto __3
	}
	goto OUT_FULL
__3:
	;
	store2(tls, q, uint16(uint64(0xE0)+(x-uint64(16))<<8))
	q += uintptr(2)
	L = L - x
	q = lzvn_copy64(tls, q, p, x)
	p += uintptr(x)
	goto __1
__2:
	;
	if !(L > uint64(3)) {
		goto __4
	}
	if !(q+uintptr(L)+uintptr(10) >= q1) {
		goto __5
	}
	goto OUT_FULL
__5:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(uint64(0xE0) + L) // 1110LLLL
	q = lzvn_copy64(tls, q, p, L)
	p += uintptr(L)
	L = uint64(0)
__4:
	;
	if M <= uint64(10)-uint64(2)*L {
		x = M
	} else {
		x = uint64(10) - uint64(2)*L
	} // x = min(10-2*L,M)
	M = M - x
	x = x - uint64(3)
	literal = load4(tls, p)
	// P is not accessed after this point

	// Relaxed capacity test covering all cases
	if !(q+uintptr(8) >= q1) {
		goto __6
	}
	goto OUT_FULL
__6:
	;

	if !(D == D_prev) {
		goto __7
	}
	if !(L == uint64(0)) {
		goto __9
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(uint64(0xF0) + (x + uint64(3))) // XM!
	goto __10
__9:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(L<<6 + x<<3 + uint64(6)) //  LLxxx110
__10:
	;
	store4(tls, q, literal)
	q += uintptr(L)
	goto __8
__7:
	if !(D < uint64(2048-2*256)) {
		goto __11
	}
	// Short dist    D>>8 in 0..5
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(D>>8 + L<<6 + x<<3) // LLxxxDDD
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(D & uint64(0xFF))
	store4(tls, q, literal)
	q += uintptr(L)
	goto __12
__11:
	if !(D >= uint64(int32(1)<<14) || M == uint64(0) || x+uint64(3)+M > uint64(34)) {
		goto __13
	}
	// Long dist
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(L<<6 + x<<3 + uint64(7))
	store2(tls, q, uint16(D))
	q += uintptr(2)
	store4(tls, q, literal)
	q += uintptr(L)
	goto __14
__13:
	// Medium distance
	x = x + M
	M = uint64(0)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(uint64(0xA0) + x>>2 + L<<3)
	store2(tls, q, uint16(D<<2|x&uint64(3)))
	q += uintptr(2)
	store4(tls, q, literal)
	q += uintptr(L)
__14:
	;
__12:
	;
__8:
	;

	// Issue remaining match
__15:
	if !(M > uint64(15)) {
		goto __16
	}
	if !(q+uintptr(2) >= q1) {
		goto __17
	}
	goto OUT_FULL
__17:
	;
	if M < uint64(271) {
		x = M
	} else {
		x = uint64(271)
	}
	store2(tls, q, uint16(uint64(0xf0)+(x-uint64(16))<<8))
	q += uintptr(2)
	M = M - x
	goto __15
__16:
	;
	if !(M > uint64(0)) {
		goto __18
	}
	if !(q+uintptr(1) >= q1) {
		goto __19
	}
	goto OUT_FULL
__19:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(uint64(0xF0) + M) // M = 0..15
__18:
	;

	return q

OUT_FULL:
	return q1
}

// ===============================================================
// Conversions

//! @abstract Return 32-bit value to store for offset x.
func offset_to_s32(tls *libc.TLS, x lzvn_offset) int32_t { /* lzvn_encode_base.c:186:23: */
	return int32_t(x)
}

//! @abstract Get offset from 32-bit stored value x.
func offset_from_s32(tls *libc.TLS, x int32_t) lzvn_offset { /* lzvn_encode_base.c:189:27: */
	return lzvn_offset(x)
}

// ===============================================================
// Hash and Matching

//! @abstract Get hash in range \c [0,LZVN_ENCODE_HASH_VALUES-1] from 3 bytes in i.
func hash3i(tls *libc.TLS, i uint32_t) uint32_t { /* lzvn_encode_base.c:195:24: */
	i = i & uint32_t(0xffffff) // truncate to 24-bit input (slightly increases compression ratio)
	var h uint32_t = i * uint32_t(1+int32(1)<<6+int32(1)<<12) >> 12
	return h & uint32_t(int32(1)<<14-1)
}

// ! @abstract Return the number [0, 4] of zero bytes in \p x, starting from the
// least significant byte.
func trailing_zero_bytes(tls *libc.TLS, x uint32_t) lzvn_offset { /* lzvn_encode_base.c:203:27: */
	if x == uint32_t(0) {
		return int64(4)
	}
	return int64(__builtin_ctzl(tls, int64(x)) >> 3)
}

// ! @abstract Return the number [0, 4] of matching chars between values at
// \p src+i and \p src+j, starting from the least significant byte.
// Assumes we can read 4 chars from each position.
func nmatch4(tls *libc.TLS, src uintptr, i lzvn_offset, j lzvn_offset) lzvn_offset { /* lzvn_encode_base.c:210:27: */
	var vi uint32_t = load4(tls, src+uintptr(i))
	var vj uint32_t = load4(tls, src+uintptr(j))
	return trailing_zero_bytes(tls, vi^vj)
}

// ! @abstract Check if l_begin, m_begin, m0_begin (m0_begin < m_begin) can be
// expanded to a match of length at least 3.
// @param m_begin new string to match.
// @param m0_begin candidate old string.
// @param src source buffer, with valid indices src_begin <= i < src_end.
// (src_begin may be <0)
// @return If a match can be found, return 1 and set all \p match fields,
// otherwise return 0.
// @note \p *match should be 0 before the call.
func lzvn_find_match(tls *libc.TLS, src uintptr, src_begin lzvn_offset, src_end lzvn_offset, l_begin lzvn_offset, m0_begin lzvn_offset, m_begin lzvn_offset, match uintptr) int32 { /* lzvn_encode_base.c:226:19: */
	var n lzvn_offset = nmatch4(tls, src, m_begin, m0_begin)
	if n < int64(3) {
		return 0
	} // no match

	var D lzvn_offset = m_begin - m0_begin // actual distance
	if D <= int64(0) || D > int64(0xffff) {
		return 0
	} // distance out of range

	// Expand forward
	var m_end lzvn_offset = m_begin + n
	for n == int64(4) && m_end+int64(4) < src_end {
		n = nmatch4(tls, src, m_end, m_end-D)
		m_end = m_end + n
	}

	// Expand backwards over literal
	for m0_begin > src_begin && m_begin > l_begin && int32(*(*uint8)(unsafe.Pointer(src + uintptr(m_begin-int64(1))))) == int32(*(*uint8)(unsafe.Pointer(src + uintptr(m0_begin-int64(1))))) {
		m0_begin--
		m_begin--
	}

	// OK, we keep it, update MATCH
	var M lzvn_offset = m_end - m_begin // match length
	(*lzvn_match_info)(unsafe.Pointer(match)).m_begin = m_begin
	(*lzvn_match_info)(unsafe.Pointer(match)).m_end = m_end
	(*lzvn_match_info)(unsafe.Pointer(match)).K = M - func() int64 {
		if D < int64(0x600) {
			return int64(2)
		}
		return int64(3)
	}()
	(*lzvn_match_info)(unsafe.Pointer(match)).M = M
	(*lzvn_match_info)(unsafe.Pointer(match)).D = D

	return 1 // OK
}

// ! @abstract Same as lzvn_find_match, but we already know that N bytes do
//  match (N<=4).
func lzvn_find_matchN(tls *libc.TLS, src uintptr, src_begin lzvn_offset, src_end lzvn_offset, l_begin lzvn_offset, m0_begin lzvn_offset, m_begin lzvn_offset, n lzvn_offset, match uintptr) int32 { /* lzvn_encode_base.c:266:19: */
	// We can skip the first comparison on 4 bytes
	if n < int64(3) {
		return 0
	} // no match

	var D lzvn_offset = m_begin - m0_begin // actual distance
	if D <= int64(0) || D > int64(0xffff) {
		return 0
	} // distance out of range

	// Expand forward
	var m_end lzvn_offset = m_begin + n
	for n == int64(4) && m_end+int64(4) < src_end {
		n = nmatch4(tls, src, m_end, m_end-D)
		m_end = m_end + n
	}

	// Expand backwards over literal
	for m0_begin > src_begin && m_begin > l_begin && int32(*(*uint8)(unsafe.Pointer(src + uintptr(m_begin-int64(1))))) == int32(*(*uint8)(unsafe.Pointer(src + uintptr(m0_begin-int64(1))))) {
		m0_begin--
		m_begin--
	}

	// OK, we keep it, update MATCH
	var M lzvn_offset = m_end - m_begin // match length
	(*lzvn_match_info)(unsafe.Pointer(match)).m_begin = m_begin
	(*lzvn_match_info)(unsafe.Pointer(match)).m_end = m_end
	(*lzvn_match_info)(unsafe.Pointer(match)).K = M - func() int64 {
		if D < int64(0x600) {
			return int64(2)
		}
		return int64(3)
	}()
	(*lzvn_match_info)(unsafe.Pointer(match)).M = M
	(*lzvn_match_info)(unsafe.Pointer(match)).D = D

	return 1 // OK
}

// ===============================================================
// Encoder Backend

// ! @abstract Emit a match and update state.
// @return number of bytes written to \p dst. May be 0 if there is no more space
// in \p dst to emit the match.
func lzvn_emit_match(tls *libc.TLS, state uintptr, match lzvn_match_info) lzvn_offset { /* lzvn_encode_base.c:310:27: */
	var L size_t = size_t(match.m_begin - (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal) // literal count
	var M size_t = size_t(match.M)                                                                        // match length
	var D size_t = size_t(match.D)                                                                        // match distance
	var D_prev size_t = size_t((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).d_prev)                 // previously emitted match distance
	var dst uintptr = emit(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src+uintptr((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal), (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst,
		(**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst_end, L, M, D, D_prev)
	// Check if DST is full
	if dst >= (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst_end {
		return int64(0) // FULL
	}

	// Update state
	var dst_used lzvn_offset = lzvn_offset((int64(dst) - int64((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst)) / 1)
	(*lzvn_encoder_state)(unsafe.Pointer(state)).d_prev = match.D
	(*lzvn_encoder_state)(unsafe.Pointer(state)).dst = dst
	(*lzvn_encoder_state)(unsafe.Pointer(state)).src_literal = match.m_end
	return dst_used
}

// ! @abstract Emit a n-bytes literal and update state.
// @return number of bytes written to \p dst. May be 0 if there is no more space
// in \p dst to emit the literal.
func lzvn_emit_literal(tls *libc.TLS, state uintptr, n lzvn_offset) lzvn_offset { /* lzvn_encode_base.c:334:27: */
	var L size_t = size_t(n)
	var dst uintptr = emit_literal(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src+uintptr((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal), (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst,
		(**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst_end, L)
	// Check if DST is full
	if dst >= (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst_end {
		return int64(0)
	} // FULL

	// Update state
	var dst_used lzvn_offset = lzvn_offset((int64(dst) - int64((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst)) / 1)
	(*lzvn_encoder_state)(unsafe.Pointer(state)).dst = dst
	*(*lzvn_offset)(unsafe.Pointer(state + 40)) += n
	return dst_used
}

// ! @abstract Emit end-of-stream and update state.
// @return number of bytes written to \p dst. May be 0 if there is no more space
// in \p dst to emit the instruction.
func lzvn_emit_end_of_stream(tls *libc.TLS, state uintptr) lzvn_offset { /* lzvn_encode_base.c:353:27: */
	// Do we have 8 byte in dst?
	if (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst_end < (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst+uintptr(8) {
		return int64(0)
	} // FULL

	// Insert end marker and update state
	store8(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).dst, uint64(0x06)) // end-of-stream command
	**(**uintptr)(unsafe.Pointer(uintptr(state + 48))) += uintptr(8)
	return int64(8) // dst_used
}

// ===============================================================
// Encoder Functions

//! @abstract Initialize encoder table in \p state, uses current I/O parameters.
func lzvn_init_table(tls *libc.TLS, state uintptr) { /* lzvn_encode_base.c:368:20: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var index lzvn_offset = int64(-0xffff) // max match distance
	if index < (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_begin {
		index = (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_begin
	}
	var value uint32_t = load4(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src+uintptr(index))
	// var e lzvn_encode_entry_type at bp, 32

	{
		var i int32 = 0
	__1:
		if !(i < 4) {
			goto __3
		}
		{
			*(*int32_t)(unsafe.Pointer(bp + uintptr(i)*4)) = offset_to_s32(tls, index)
			*(*uint32_t)(unsafe.Pointer(bp + 16 + uintptr(i)*4)) = value

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	{
		var u int32 = 0
	__4:
		if !(u < int32(1)<<14) {
			goto __6
		}
		*(*lzvn_encode_entry_type)(unsafe.Pointer((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).table + uintptr(u)*32)) = lzvn_encode_entry_type(**(**lzvn_encode_entry_type)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* e */))
		goto __5
	__5:
		u++
		goto __4
		goto __6
	__6:
	} // fill entire table
}

func lzvn_encode(tls *libc.TLS, state uintptr) { /* lzvn_encode_base.c:383:6: */
	bp := tls.Alloc(280)
	defer tls.Free(280)

	var NO_MATCH lzvn_match_info
	// var m1 lzvn_match_info at bp+uintptr(80), 40

	// var m11 lzvn_match_info at bp+uintptr(120), 40

	// var m12 lzvn_match_info at bp+uintptr(160), 40

	// var m13 lzvn_match_info at bp+uintptr(200), 40

	// var m14 lzvn_match_info at bp+uintptr(240), 40

	// Get 4 bytes at src_current
	var vi uint32_t

	// Compute new hash H at position I, and push value into position table
	var h int32 // index of first entry

	// Read table entries for H
	// var e lzvn_encode_entry_type at bp+uintptr(32), 32

	// Update entry with index=current and value=vi
	// var updated_e lzvn_encode_entry_type at bp, 32

	// Update best with candidate if better
	// Check candidate. Keep if better.
	// Emit match M. Return if we don't have enough space in the destination buffer
	// Emit literal of length L. Return if we don't have enough space in the
	// destination buffer

	var incoming lzvn_match_info

	// Check candidates in order (closest first)
	// var diffs [4]uint32_t at bp+uintptr(64), 16

	var k int32        // XOR, 0 if equal
	var ik lzvn_offset // index
	var nk lzvn_offset
	NO_MATCH = lzvn_match_info{}

__1:
	if !((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current < (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current_end) {
		goto __3
	}
	vi = load4(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src+uintptr((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current))
	h = int32(hash3i(tls, vi))
	**(**lzvn_encode_entry_type)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(32)) /* e */) = *(*lzvn_encode_entry_type)(unsafe.Pointer((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).table + uintptr(h)*32)) // rotate values, so we will replace the oldest
	*(*int32_t)(unsafe.Pointer(bp)) = offset_to_s32(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current)
	*(*int32_t)(unsafe.Pointer(bp + 1*4)) = *(*int32_t)(unsafe.Pointer(bp + uintptr(32)))
	*(*int32_t)(unsafe.Pointer(bp + 2*4)) = *(*int32_t)(unsafe.Pointer(bp + uintptr(32) + 1*4))
	*(*int32_t)(unsafe.Pointer(bp + 3*4)) = *(*int32_t)(unsafe.Pointer(bp + uintptr(32) + 2*4))
	*(*uint32_t)(unsafe.Pointer(bp + 16)) = vi
	*(*uint32_t)(unsafe.Pointer(bp + 16 + 1*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(32) + 16))
	*(*uint32_t)(unsafe.Pointer(bp + 16 + 2*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(32) + 16 + 1*4))
	*(*uint32_t)(unsafe.Pointer(bp + 16 + 3*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(32) + 16 + 2*4))

	// Do not check matches if still in previously emitted match
	if !((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current < (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal) {
		goto __4
	}
	goto after_emit
__4:
	;
	incoming = NO_MATCH
	{
		k = 0
	__5:
		if !(k < 4) {
			goto __7
		}
		*(*uint32_t)(unsafe.Pointer(bp + uintptr(64) + uintptr(k)*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(32) + 16 + uintptr(k)*4)) ^ vi
		goto __6
	__6:
		k++
		goto __5
		goto __7
	__7:
	} // match byte count

	// The values stored in e.xyzw are 32-bit signed indices, extended to signed
	// type lzvn_offset
	ik = offset_from_s32(tls, *(*int32_t)(unsafe.Pointer(bp + uintptr(32))))
	nk = trailing_zero_bytes(tls, *(*uint32_t)(unsafe.Pointer(bp + uintptr(64))))
__8:
	if !(lzvn_find_matchN(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_begin, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_end, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal, ik, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current, nk, bp+uintptr(80)) != 0) {
		goto __11
	}
__12:
	if !((*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(80))).K > incoming.K || (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(80))).K == incoming.K && (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(80))).m_end > incoming.m_end+int64(1)) {
		goto __15
	}
	incoming = lzvn_match_info(**(**lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(80)) /* m1 */))
__15:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__11:
	;
	goto __9
__9:
	if 0 != 0 {
		goto __8
	}
	goto __10
__10:
	;
	ik = offset_from_s32(tls, *(*int32_t)(unsafe.Pointer(bp + uintptr(32) + 1*4)))
	nk = trailing_zero_bytes(tls, *(*uint32_t)(unsafe.Pointer(bp + uintptr(64) + 1*4)))
__16:
	if !(lzvn_find_matchN(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_begin, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_end, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal, ik, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current, nk, bp+uintptr(120)) != 0) {
		goto __19
	}
__20:
	if !((*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(120))).K > incoming.K || (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(120))).K == incoming.K && (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(120))).m_end > incoming.m_end+int64(1)) {
		goto __23
	}
	incoming = lzvn_match_info(**(**lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(120)) /* m11 */))
__23:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
__19:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
	ik = offset_from_s32(tls, *(*int32_t)(unsafe.Pointer(bp + uintptr(32) + 2*4)))
	nk = trailing_zero_bytes(tls, *(*uint32_t)(unsafe.Pointer(bp + uintptr(64) + 2*4)))
__24:
	if !(lzvn_find_matchN(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_begin, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_end, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal, ik, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current, nk, bp+uintptr(160)) != 0) {
		goto __27
	}
__28:
	if !((*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(160))).K > incoming.K || (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(160))).K == incoming.K && (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(160))).m_end > incoming.m_end+int64(1)) {
		goto __31
	}
	incoming = lzvn_match_info(**(**lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(160)) /* m12 */))
__31:
	;
	goto __29
__29:
	if 0 != 0 {
		goto __28
	}
	goto __30
__30:
	;
__27:
	;
	goto __25
__25:
	if 0 != 0 {
		goto __24
	}
	goto __26
__26:
	;
	ik = offset_from_s32(tls, *(*int32_t)(unsafe.Pointer(bp + uintptr(32) + 3*4)))
	nk = trailing_zero_bytes(tls, *(*uint32_t)(unsafe.Pointer(bp + uintptr(64) + 3*4)))
__32:
	if !(lzvn_find_matchN(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_begin, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_end, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal, ik, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current, nk, bp+uintptr(200)) != 0) {
		goto __35
	}
__36:
	if !((*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(200))).K > incoming.K || (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(200))).K == incoming.K && (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(200))).m_end > incoming.m_end+int64(1)) {
		goto __39
	}
	incoming = lzvn_match_info(**(**lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(200)) /* m13 */))
__39:
	;
	goto __37
__37:
	if 0 != 0 {
		goto __36
	}
	goto __38
__38:
	;
__35:
	;
	goto __33
__33:
	if 0 != 0 {
		goto __32
	}
	goto __34
__34:
	;

	// Check candidate at previous distance
	if !((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).d_prev != int64(0)) {
		goto __40
	}
	if !(lzvn_find_match(tls, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_begin, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_end,
		(**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current-(**(**lzvn_encoder_state)(unsafe.Pointer(&state))).d_prev,
		(**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current, bp+uintptr(240)) != 0) {
		goto __41
	}
	(*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(240) /* &m14 */)).K = (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(240))).M - int64(1) // fix K for D_prev
__42:
	if !((*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(240))).K > incoming.K || (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(240))).K == incoming.K && (*lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(240))).m_end > incoming.m_end+int64(1)) {
		goto __45
	}
	incoming = lzvn_match_info(**(**lzvn_match_info)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(240)) /* m14 */))
__45:
	;
	goto __43
__43:
	if 0 != 0 {
		goto __42
	}
	goto __44
__44:
	;
__41:
	;
__40:
	;

	// Here we have the best candidate in incoming, may be NO_MATCH

	// If no incoming match, and literal backlog becomes too high, emit pending
	// match, or literals if there is no pending match
	if !(incoming.M == int64(0)) {
		goto __46
	}
	if !((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_current-(**(**lzvn_encoder_state)(unsafe.Pointer(&state))).src_literal >= int64(400)) {
		goto __47
	} // at this point, we always have
	// current >= literal

	if !((*lzvn_encoder_state)(unsafe.Pointer(state)).pending.M != int64(0)) {
		goto __48
	}
__50:
	if !(lzvn_emit_match(tls, state, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).pending) == int64(0)) {
		goto __53
	}
	return
__53:
	;
	goto __51
__51:
	if 0 != 0 {
		goto __50
	}
	goto __52
__52:
	;
	(*lzvn_encoder_state)(unsafe.Pointer(state)).pending = NO_MATCH
	goto __49
__48:
__54:
	if !(lzvn_emit_literal(tls, state, int64(271)) == int64(0)) {
		goto __57
	}
	return
__57:
	;
	goto __55
__55:
	if 0 != 0 {
		goto __54
	}
	goto __56
__56:
	; // emit long literal (271 is the longest literal size we allow)
__49:
	;
__47:
	;
	goto after_emit
__46:
	;

	if !((*lzvn_encoder_state)(unsafe.Pointer(state)).pending.M == int64(0)) {
		goto __58
	}
	// NOTE. Here, we can also emit incoming right away. It will make the
	// encoder 1.5x faster, at a cost of ~10% lower compression ratio:
	// EMIT_MATCH(incoming);
	// state->pending = NO_MATCH;

	// No pending match, emit nothing, keep incoming
	(*lzvn_encoder_state)(unsafe.Pointer(state)).pending = incoming
	goto __59
__58:
	// Here we have both incoming and pending
	if !((*lzvn_encoder_state)(unsafe.Pointer(state)).pending.m_end <= incoming.m_begin) {
		goto __60
	}
	// No overlap: emit pending, keep incoming
__62:
	if !(lzvn_emit_match(tls, state, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).pending) == int64(0)) {
		goto __65
	}
	return
__65:
	;
	goto __63
__63:
	if 0 != 0 {
		goto __62
	}
	goto __64
__64:
	;
	(*lzvn_encoder_state)(unsafe.Pointer(state)).pending = incoming
	goto __61
__60:
	// If pending is better, emit pending and discard incoming.
	// Otherwise, emit incoming and discard pending.
	if !(incoming.K > (*lzvn_encoder_state)(unsafe.Pointer(state)).pending.K) {
		goto __66
	}
	(*lzvn_encoder_state)(unsafe.Pointer(state)).pending = incoming
__66:
	;
__67:
	if !(lzvn_emit_match(tls, state, (**(**lzvn_encoder_state)(unsafe.Pointer(&state))).pending) == int64(0)) {
		goto __70
	}
	return
__70:
	;
	goto __68
__68:
	if 0 != 0 {
		goto __67
	}
	goto __69
__69:
	;
	(*lzvn_encoder_state)(unsafe.Pointer(state)).pending = NO_MATCH
__61:
	;
__59:
	;

after_emit:

	// We commit state changes only after we tried to emit instructions, so we
	// can restart in the same state in case dst was full and we quit the loop.
	*(*lzvn_encode_entry_type)(unsafe.Pointer((**(**lzvn_encoder_state)(unsafe.Pointer(&state))).table + uintptr(h)*32)) = lzvn_encode_entry_type(**(**lzvn_encode_entry_type)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* updated_e */))

	goto __2
__2:
	(*lzvn_encoder_state)(unsafe.Pointer(state)).src_current++
	goto __1
	goto __3
__3:
	// i loop

	// Do not emit pending match here. We do it only at the end of stream.
}

// ===============================================================
// API entry points

func lzvn_encode_scratch_size(tls *libc.TLS) size_t { /* lzvn_encode_base.c:534:8: */
	return uint64(int32(1)<<14) * uint64(unsafe.Sizeof(lzvn_encode_entry_type{}))
}

func lzvn_encode_partial(tls *libc.TLS, dst uintptr, dst_size size_t, src uintptr, src_size size_t, src_used uintptr, work uintptr) size_t { /* lzvn_encode_base.c:536:15: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// Min size checks to avoid accessing memory outside buffers.
	if dst_size < uint64(8) {
		*(*size_t)(unsafe.Pointer(src_used)) = uint64(0)
		return uint64(0)
	}
	// Max input size check (limit to offsets on uint32_t).
	if src_size > uint64(0xffffffff) {
		src_size = uint64(0xffffffff)
	}

	// Setup encoder state
	// var state lzvn_encoder_state at bp, 128

	libc.X__builtin___memset_chk(tls, bp, 0, uint64(unsafe.Sizeof(lzvn_encoder_state{})), libc.X__builtin_object_size(tls, bp, 0))

	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).src = src
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).src_begin = int64(0)
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).src_end = lzvn_offset(src_size)
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).src_literal = int64(0)
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).src_current = int64(0)
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).dst = dst
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).dst_begin = dst
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).dst_end = dst + uintptr(dst_size) - uintptr(8) // reserve 8 bytes for end-of-stream
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).table = work

	// Do not encode if the input buffer is too small. We'll emit a literal instead.
	if src_size >= uint64(8) {

		(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).src_current_end = lzvn_offset(src_size) - int64(8)
		lzvn_init_table(tls, bp)
		lzvn_encode(tls, bp)

	}

	// No need to test the return value: src_literal will not be updated on failure,
	// and we will fail later.
	lzvn_emit_literal(tls, bp, (*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).src_end-(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).src_literal)

	// Restore original size, so end-of-stream always succeeds, and emit it
	(*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).dst_end = dst + uintptr(dst_size)
	lzvn_emit_end_of_stream(tls, bp)

	*(*size_t)(unsafe.Pointer(src_used)) = size_t((*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &state */)).src_literal)
	return size_t((int64((*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).dst) - int64((*lzvn_encoder_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).dst_begin)) / 1)
}

func lzvn_encode_buffer(tls *libc.TLS, dst uintptr, dst_size size_t, src uintptr, src_size size_t, work uintptr) size_t { /* lzvn_encode_base.c:584:8: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	**(**size_t)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* src_used */) = uint64(0)
	var dst_used size_t = lzvn_encode_partial(tls, dst, dst_size, src, src_size, bp, work)
	if size_t(**(**size_t)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))))) != src_size {
		return uint64(0)
	} // could not encode entire input stream = fail
	return dst_used // return encoded size
}

// MARK: - L, M, D encoding constants for LZFSE

//  Largest encodable L (literal length), M (match length) and D (match
//  distance) values.

// ! @abstract The L, M, D data streams are all encoded as a "base" value, which is
// FSE-encoded, and an "extra bits" value, which is the difference between
// value and base, and is simply represented as a raw bit value (because it
// is the low-order bits of a larger number, not much entropy can be
// extracted from these bits by more complex encoding schemes). The following
// tables represent the number of low-order bits to encode separately and the
// base values for each of L, M, and D.
//
// @note The inverse tables for mapping the other way are significantly larger.
// Those tables have been split out to lzfse_encode_tables.h in order to keep
// this file relatively small.
var l_extra_bits6 = [20]uint8_t{
	uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(2), uint8_t(3), uint8_t(5), uint8_t(8),
} /* lzfse_internal.h:588:22 */
var l_base_value6 = [20]int32_t{
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 28, 60,
} /* lzfse_internal.h:591:22 */
var m_extra_bits6 = [20]uint8_t{
	uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(3), uint8_t(5), uint8_t(8), uint8_t(11),
} /* lzfse_internal.h:594:22 */
var m_base_value6 = [20]int32_t{
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24, 56, 312,
} /* lzfse_internal.h:597:22 */
var d_extra_bits6 = [64]uint8_t{
	uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(1), uint8_t(1), uint8_t(1), uint8_t(1), uint8_t(2), uint8_t(2), uint8_t(2), uint8_t(2), uint8_t(3), uint8_t(3), uint8_t(3), uint8_t(3),
	uint8_t(4), uint8_t(4), uint8_t(4), uint8_t(4), uint8_t(5), uint8_t(5), uint8_t(5), uint8_t(5), uint8_t(6), uint8_t(6), uint8_t(6), uint8_t(6), uint8_t(7), uint8_t(7), uint8_t(7), uint8_t(7),
	uint8_t(8), uint8_t(8), uint8_t(8), uint8_t(8), uint8_t(9), uint8_t(9), uint8_t(9), uint8_t(9), uint8_t(10), uint8_t(10), uint8_t(10), uint8_t(10), uint8_t(11), uint8_t(11), uint8_t(11), uint8_t(11),
	uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(15), uint8_t(15), uint8_t(15), uint8_t(15),
} /* lzfse_internal.h:600:22 */
var d_base_value6 = [64]int32_t{
	0, 1, 2, 3, 4, 6, 8, 10, 12, 16,
	20, 24, 28, 36, 44, 52, 60, 76, 92, 108,
	124, 156, 188, 220, 252, 316, 380, 444, 508, 636,
	764, 892, 1020, 1276, 1532, 1788, 2044, 2556, 3068, 3580,
	4092, 5116, 6140, 7164, 8188, 10236, 12284, 14332, 16380, 20476,
	24572, 28668, 32764, 40956, 49148, 57340, 65532, 81916, 98300, 114684,
	131068, 163836, 196604, 229372,
} /* lzfse_internal.h:606:22 */

//
// Copyright (c) 2015-2016, Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//
// 1.  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//
// 2.  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer
//     in the documentation and/or other materials provided with the distribution.
//
// 3.  Neither the name of the copyright holder(s) nor the names of any contributors may be used to endorse or promote products derived
//     from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

func l_base_from_value(tls *libc.TLS, value int32_t) uint8_t { /* lzfse_encode_tables.h:29:23: */
	return sym[value]
}

var sym = [316]uint8_t{
	uint8_t(0), uint8_t(1), uint8_t(2), uint8_t(3), uint8_t(4), uint8_t(5), uint8_t(6), uint8_t(7), uint8_t(8), uint8_t(9), uint8_t(10), uint8_t(11), uint8_t(12), uint8_t(13), uint8_t(14), uint8_t(15), uint8_t(16), uint8_t(16),
	uint8_t(16), uint8_t(16), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19)} /* lzfse_encode_tables.h:30:24 */

func m_base_from_value(tls *libc.TLS, value int32_t) uint8_t { /* lzfse_encode_tables.h:51:23: */
	return sym1[value]
}

var sym1 = [2360]uint8_t{
	uint8_t(0), uint8_t(1), uint8_t(2), uint8_t(3), uint8_t(4), uint8_t(5), uint8_t(6), uint8_t(7), uint8_t(8), uint8_t(9), uint8_t(10), uint8_t(11), uint8_t(12), uint8_t(13), uint8_t(14), uint8_t(15), uint8_t(16), uint8_t(16),
	uint8_t(16), uint8_t(16), uint8_t(16), uint8_t(16), uint8_t(16), uint8_t(16), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17),
	uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17), uint8_t(17),
	uint8_t(17), uint8_t(17), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18),
	uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(18), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19), uint8_t(19),
	uint8_t(19), uint8_t(19)} /* lzfse_encode_tables.h:52:24 */

func d_base_from_value(tls *libc.TLS, value int32_t) uint8_t { /* lzfse_encode_tables.h:188:23: */
	var index int32 = 0
	var in_range_k int32
	in_range_k = libc.Bool32(value >= 0 && value < 60)
	index = index | ((value-0)>>0+0)&-in_range_k
	in_range_k = libc.Bool32(value >= 60 && value < 1020)
	index = index | ((value-60)>>4+64)&-in_range_k
	in_range_k = libc.Bool32(value >= 1020 && value < 16380)
	index = index | ((value-1020)>>8+128)&-in_range_k
	in_range_k = libc.Bool32(value >= 16380 && value < 262140)
	index = index | ((value-16380)>>12+192)&-in_range_k
	return sym2[index&255]
}

var sym2 = [256]uint8_t{
	uint8_t(0), uint8_t(1), uint8_t(2), uint8_t(3), uint8_t(4), uint8_t(4), uint8_t(5), uint8_t(5), uint8_t(6), uint8_t(6), uint8_t(7), uint8_t(7), uint8_t(8), uint8_t(8), uint8_t(8), uint8_t(8), uint8_t(9), uint8_t(9),
	uint8_t(9), uint8_t(9), uint8_t(10), uint8_t(10), uint8_t(10), uint8_t(10), uint8_t(11), uint8_t(11), uint8_t(11), uint8_t(11), uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(12), uint8_t(12),
	uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(13), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(14), uint8_t(15), uint8_t(15),
	uint8_t(15), uint8_t(15), uint8_t(15), uint8_t(15), uint8_t(15), uint8_t(15), uint8_t(16), uint8_t(16), uint8_t(16), uint8_t(16), uint8_t(16), uint8_t(17), uint8_t(18), uint8_t(19), uint8_t(20), uint8_t(20), uint8_t(21), uint8_t(21),
	uint8_t(22), uint8_t(22), uint8_t(23), uint8_t(23), uint8_t(24), uint8_t(24), uint8_t(24), uint8_t(24), uint8_t(25), uint8_t(25), uint8_t(25), uint8_t(25), uint8_t(26), uint8_t(26), uint8_t(26), uint8_t(26), uint8_t(27), uint8_t(27),
	uint8_t(27), uint8_t(27), uint8_t(28), uint8_t(28), uint8_t(28), uint8_t(28), uint8_t(28), uint8_t(28), uint8_t(28), uint8_t(28), uint8_t(29), uint8_t(29), uint8_t(29), uint8_t(29), uint8_t(29), uint8_t(29), uint8_t(29), uint8_t(29),
	uint8_t(30), uint8_t(30), uint8_t(30), uint8_t(30), uint8_t(30), uint8_t(30), uint8_t(30), uint8_t(30), uint8_t(31), uint8_t(31), uint8_t(31), uint8_t(31), uint8_t(31), uint8_t(31), uint8_t(31), uint8_t(31), uint8_t(32), uint8_t(32),
	uint8_t(32), uint8_t(32), uint8_t(32), uint8_t(33), uint8_t(34), uint8_t(35), uint8_t(36), uint8_t(36), uint8_t(37), uint8_t(37), uint8_t(38), uint8_t(38), uint8_t(39), uint8_t(39), uint8_t(40), uint8_t(40), uint8_t(40), uint8_t(40),
	uint8_t(41), uint8_t(41), uint8_t(41), uint8_t(41), uint8_t(42), uint8_t(42), uint8_t(42), uint8_t(42), uint8_t(43), uint8_t(43), uint8_t(43), uint8_t(43), uint8_t(44), uint8_t(44), uint8_t(44), uint8_t(44), uint8_t(44), uint8_t(44),
	uint8_t(44), uint8_t(44), uint8_t(45), uint8_t(45), uint8_t(45), uint8_t(45), uint8_t(45), uint8_t(45), uint8_t(45), uint8_t(45), uint8_t(46), uint8_t(46), uint8_t(46), uint8_t(46), uint8_t(46), uint8_t(46), uint8_t(46), uint8_t(46),
	uint8_t(47), uint8_t(47), uint8_t(47), uint8_t(47), uint8_t(47), uint8_t(47), uint8_t(47), uint8_t(47), uint8_t(48), uint8_t(48), uint8_t(48), uint8_t(48), uint8_t(48), uint8_t(49), uint8_t(50), uint8_t(51), uint8_t(52), uint8_t(52),
	uint8_t(53), uint8_t(53), uint8_t(54), uint8_t(54), uint8_t(55), uint8_t(55), uint8_t(56), uint8_t(56), uint8_t(56), uint8_t(56), uint8_t(57), uint8_t(57), uint8_t(57), uint8_t(57), uint8_t(58), uint8_t(58), uint8_t(58), uint8_t(58),
	uint8_t(59), uint8_t(59), uint8_t(59), uint8_t(59), uint8_t(60), uint8_t(60), uint8_t(60), uint8_t(60), uint8_t(60), uint8_t(60), uint8_t(60), uint8_t(60), uint8_t(61), uint8_t(61), uint8_t(61), uint8_t(61), uint8_t(61), uint8_t(61),
	uint8_t(61), uint8_t(61), uint8_t(62), uint8_t(62), uint8_t(62), uint8_t(62), uint8_t(62), uint8_t(62), uint8_t(62), uint8_t(62), uint8_t(63), uint8_t(63), uint8_t(63), uint8_t(63), uint8_t(63), uint8_t(63), uint8_t(63), uint8_t(63),
	uint8_t(0), uint8_t(0), uint8_t(0), uint8_t(0)} /* lzfse_encode_tables.h:189:24 */

//! @abstract Get hash in range [0, LZFSE_ENCODE_HASH_VALUES-1] from 4 bytes in X.
func hashX(tls *libc.TLS, x uint32_t) uint32_t { /* lzfse_encode_base.c:28:24: */
	return x * 2654435761 >> (32 - 14) // Knuth multiplicative hash
}

// ! @abstract Return value with all 0 except nbits<=32 unsigned bits from V
// at bit offset OFFSET.
// V is assumed to fit on nbits bits.
func setField(tls *libc.TLS, v uint32_t, offset int32, nbits int32) uint64_t { /* lzfse_encode_base.c:36:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(offset+nbits < 64 && offset >= 0 && nbits <= 32)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__88)), ts+uintptr(1004), 37, ts+uintptr(662))
	} else {
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(nbits == 32 || v < uint32(1)<<nbits)), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__88)), ts+uintptr(1004), 38, ts+uintptr(1068))
	} else {
	}
	return uint64_t(v) << uint64_t(offset)
}

var __func__88 = *(*[9]int8)(unsafe.Pointer(ts + uintptr(1103))) /* lzfse_encode_base.c:36:68 */

// ! @abstract Encode all fields, except freq, from a
// lzfse_compressed_block_header_v1 to a lzfse_compressed_block_header_v2.
// All but the header_size and freq fields of the output are modified.
func lzfse_encode_v1_state(tls *libc.TLS, out uintptr, in uintptr) { /* lzfse_encode_base.c:46:1: */
	(*lzfse_compressed_block_header_v2)(unsafe.Pointer(out)).magic = uint32_t(0x32787662)
	(*lzfse_compressed_block_header_v2)(unsafe.Pointer(out)).n_raw_bytes = (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).n_raw_bytes

	// Literal state
	*(*uint64_t)(unsafe.Pointer(out + 8)) = setField(tls, (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).n_literals, 0, 20) | setField(tls, (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).n_literal_payload_bytes, 20, 20) | setField(tls, (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).n_matches, 40, 20) | setField(tls, uint32(7+(**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).literal_bits), 60, 3)
	*(*uint64_t)(unsafe.Pointer(out + 8 + 1*8)) = setField(tls, uint32(*(*uint16_t)(unsafe.Pointer(in + 32))), 0, 10) | setField(tls, uint32(*(*uint16_t)(unsafe.Pointer(in + 32 + 1*2))), 10, 10) | setField(tls, uint32(*(*uint16_t)(unsafe.Pointer(in + 32 + 2*2))), 20, 10) | setField(tls, uint32(*(*uint16_t)(unsafe.Pointer(in + 32 + 3*2))), 30, 10) | setField(tls, (**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).n_lmd_payload_bytes, 40, 20) | setField(tls, uint32(7+(**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).lmd_bits), 60, 3)
	*(*uint64_t)(unsafe.Pointer(out + 8 + 2*8)) = *(*uint64_t)(unsafe.Pointer(out + 8 + 2*8)) |
		setField(tls, uint32((**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).l_state), 32, 10) | setField(tls, uint32((**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).m_state), 42, 10) | setField(tls, uint32((**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(&in))).d_state), 52, 10)
}

// ! @abstract Encode an entry value in a freq table. Return bits, and sets
// *nbits to the number of bits to serialize.
func lzfse_encode_v1_freq_value(tls *libc.TLS, value int32, nbits uintptr) uint32_t { /* lzfse_encode_base.c:69:24: */
	// Fixed Huffman code, bits are read from LSB.
	// Note that we rely on the position of the first '0' bit providing the number
	// of bits.
	switch value {
	case 0:
		*(*int32)(unsafe.Pointer(nbits)) = 2
		return uint32_t(0) //    0.0
	case 1:
		*(*int32)(unsafe.Pointer(nbits)) = 2
		return uint32_t(2) //    1.0
	case 2:
		*(*int32)(unsafe.Pointer(nbits)) = 3
		return uint32_t(1) //   0.01
	case 3:
		*(*int32)(unsafe.Pointer(nbits)) = 3
		return uint32_t(5) //   1.01
	case 4:
		*(*int32)(unsafe.Pointer(nbits)) = 5
		return uint32_t(3) // 00.011
	case 5:
		*(*int32)(unsafe.Pointer(nbits)) = 5
		return uint32_t(11) // 01.011
	case 6:
		*(*int32)(unsafe.Pointer(nbits)) = 5
		return uint32_t(19) // 10.011
	case 7:
		*(*int32)(unsafe.Pointer(nbits)) = 5
		return uint32_t(27) // 11.011
	default:
		break
	}
	if value < 24 {
		*(*int32)(unsafe.Pointer(nbits)) = 8 // 4+4
		return uint32_t(7 + (value-8)<<4)    // xxxx.0111
	}
	// 24..1047
	*(*int32)(unsafe.Pointer(nbits)) = 14 // 4+10
	return uint32_t((value-24)<<4 + 15)   // xxxxxxxxxx.1111
}

// ! @abstract Encode all tables from a lzfse_compressed_block_header_v1
// to a lzfse_compressed_block_header_v2.
// Only the header_size and freq fields of the output are modified.
// @return Size of the lzfse_compressed_block_header_v2
func lzfse_encode_v1_freq_table(tls *libc.TLS, out uintptr, in uintptr) size_t { /* lzfse_encode_base.c:115:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var accum uint32_t = uint32_t(0)
	var accum_nbits int32 = 0
	var src uintptr = in + 50 // first value of first table (struct
	// will not be modified, so this code
	// will remain valid)
	var dst uintptr = out + 32
	{
		var i int32 = 0
	__1:
		if !(i < 20+20+64+256) {
			goto __3
		}
		{
			// Encode one value to accum
			**(**int32)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* nbits */) = 0
			var bits uint32_t = lzfse_encode_v1_freq_value(tls, int32(*(*uint16_t)(unsafe.Pointer(src + uintptr(i)*2))), bp)
			if libc.X__builtin_expect(tls, libc.BoolInt64(!(bits < uint32_t(int32(1)<<int32(**(**int32)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))))))), int64(0)) != 0 {
				libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__89)), ts+uintptr(1004), 129, ts+uintptr(1112))
			} else {
			}
			accum = accum | bits<<accum_nbits
			accum_nbits = accum_nbits + int32(**(**int32)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))))

			// Store bytes from accum to output buffer
			for accum_nbits >= 8 {
				*(*uint8_t)(unsafe.Pointer(dst)) = uint8_t(accum & uint32_t(0xff))
				accum >>= 8
				accum_nbits = accum_nbits - 8
				dst++
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	// Store final byte if needed
	if accum_nbits > 0 {
		*(*uint8_t)(unsafe.Pointer(dst)) = uint8_t(accum & uint32_t(0xff))
		dst++
	}

	// Return final size of out
	var header_size uint32_t = uint32_t((int64(dst) - int64(out)) / 1)
	*(*uint64_t)(unsafe.Pointer(out + 8)) = uint64(0)
	*(*uint64_t)(unsafe.Pointer(out + 8 + 1*8)) = uint64(0)
	*(*uint64_t)(unsafe.Pointer(out + 8 + 2*8)) = setField(tls, header_size, 0, 32)

	return size_t(header_size)
}

var __func__89 = *(*[27]int8)(unsafe.Pointer(ts + uintptr(1132))) /* lzfse_encode_base.c:116:72 */

// We need to limit forward match length to make sure it won't split into a too
// large number of LMD.
// The limit itself is quite large, so it doesn't really impact compression
// ratio.
// The matches may still be expanded backwards by a few bytes, so the final
// length may be greater than this limit, which is OK.

// ===============================================================
// Encoder back end

// ! @abstract Encode matches stored in STATE into a compressed/uncompressed block.
// @return LZFSE_STATUS_OK on success.
// @return LZFSE_STATUS_DST_FULL and restore initial state if output buffer is
// full.
func lzfse_encode_matches(tls *libc.TLS, s uintptr) int32 { /* lzfse_encode_base.c:171:12: */
	bp := tls.Alloc(5160)
	defer tls.Free(5160)
	// nothing to store, OK

	// var l_occ [20]uint32_t at bp, 80

	// var m_occ [20]uint32_t at bp+uintptr(80), 80

	// var d_occ [64]uint32_t at bp+uintptr(160), 256

	// var literal_occ [256]uint32_t at bp+uintptr(416), 1024

	// var l_encoder [20]fse_encoder_entry at bp+uintptr(2212), 160

	// var m_encoder [20]fse_encoder_entry at bp+uintptr(2372), 160

	// var d_encoder [64]fse_encoder_entry at bp+uintptr(2532), 512

	// var literal_encoder [256]fse_encoder_entry at bp+uintptr(3044), 2048

	var ok int32
	// var header1 lzfse_compressed_block_header_v1 at bp+uintptr(1440), 772

	var header2 uintptr

	// Keep initial state to be able to restore it if DST full
	var dst0 uintptr
	var n_literals0 uint32_t

	// Encode previous distance
	var d_prev uint32_t
	var i uint32_t

	// Update occurrence tables in all 4 streams (L,M,D,literals)
	var l_sum uint32_t
	var m_sum uint32_t
	var i1 uint32_t
	var i2 uint32_t
	var i3 uint32_t
	var i4 uint32_t
	var n uint32_t
	var d uint32_t
	var l uint32_t
	var m uint32_t
	// var out fse_out_stream at bp+uintptr(5096), 16

	// var state0 fse_state at bp+uintptr(5118), 2

	// var state1 fse_state at bp+uintptr(5116), 2

	// var state2 fse_state at bp+uintptr(5114), 2

	// var state3 fse_state at bp+uintptr(5112), 2

	// var buf uintptr at bp+uintptr(5120), 8

	var i5 uint32_t

	// D requires 23b max
	var d_value int32_t
	var d_symbol uint8_t
	var d_nbits int32_t
	var d_bits int32_t

	// M requires 17b max
	var m_value int32_t
	var m_symbol uint8_t
	var m_nbits int32_t
	var m_bits int32_t

	// L requires 14b max
	var l_value int32_t
	var l_symbol uint8_t
	var l_nbits int32_t
	var l_bits int32_t
	// var out1 fse_out_stream at bp+uintptr(5128), 16

	// var l_state fse_state at bp+uintptr(5148), 2

	// var m_state fse_state at bp+uintptr(5146), 2

	// var d_state fse_state at bp+uintptr(5144), 2

	// var buf1 uintptr at bp+uintptr(5152), 8

	var i6 uint32_t
	var d1 uint32_t
	// Revert state, DST was full

	// Revert the d_prev encoding
	var d_prev1 uint32_t
	var i7 uint32_t
	if !((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals == uint32_t(0) && (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches == uint32_t(0)) {
		goto __1
	}
	return 0
__1:
	;
	ok = 1
	**(**lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440)) /* header1 */) = lzfse_compressed_block_header_v1{}
	header2 = uintptr(0)
	dst0 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst
	n_literals0 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals

	// Add 0x00 literals until n_literals multiple of 4, since we encode 4
	// interleaved literal streams.
__2:
	if !((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals&uint32_t(3) != 0) {
		goto __3
	}
	n = libc.PostIncUint32(&(*lzfse_encoder_state)(unsafe.Pointer(s)).n_literals, 1)
	*(*uint8_t)(unsafe.Pointer(s + 120096 + uintptr(n))) = uint8_t(0)
	goto __2
__3:
	;
	d_prev = uint32_t(0)
	{
		i = uint32_t(0)
	__4:
		if !(i < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches) {
			goto __6
		}
		d = *(*uint32_t)(unsafe.Pointer(s + 80096 + uintptr(i)*4))
		if !(d == d_prev) {
			goto __7
		}
		*(*uint32_t)(unsafe.Pointer(s + 80096 + uintptr(i)*4)) = uint32_t(0)
		goto __8
	__7:
		d_prev = d
	__8:
		;
		goto __5
	__5:
		i++
		goto __4
		goto __6
	__6:
	}

	// Clear occurrence tables
	libc.X__builtin___memset_chk(tls, bp, 0, uint64(unsafe.Sizeof([20]uint32_t{})), libc.X__builtin_object_size(tls, bp, 0))
	libc.X__builtin___memset_chk(tls, bp+uintptr(80), 0, uint64(unsafe.Sizeof([20]uint32_t{})), libc.X__builtin_object_size(tls, bp+uintptr(80), 0))
	libc.X__builtin___memset_chk(tls, bp+uintptr(160), 0, uint64(unsafe.Sizeof([64]uint32_t{})), libc.X__builtin_object_size(tls, bp+uintptr(160), 0))
	libc.X__builtin___memset_chk(tls, bp+uintptr(416), 0, uint64(unsafe.Sizeof([256]uint32_t{})), libc.X__builtin_object_size(tls, bp+uintptr(416), 0))
	l_sum = uint32_t(0)
	m_sum = uint32_t(0)
	{
		i1 = uint32_t(0)
	__9:
		if !(i1 < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches) {
			goto __11
		}
		l = *(*uint32_t)(unsafe.Pointer(s + 96 + uintptr(i1)*4))
		l_sum = l_sum + l
		*(*uint32_t)(unsafe.Pointer(bp + uintptr(l_base_from_value(tls, int32(l)))*4))++
		goto __10
	__10:
		i1++
		goto __9
		goto __11
	__11:
	}
	{
		i2 = uint32_t(0)
	__12:
		if !(i2 < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches) {
			goto __14
		}
		m = *(*uint32_t)(unsafe.Pointer(s + 40096 + uintptr(i2)*4))
		m_sum = m_sum + m
		*(*uint32_t)(unsafe.Pointer(bp + uintptr(80) + uintptr(m_base_from_value(tls, int32(m)))*4))++
		goto __13
	__13:
		i2++
		goto __12
		goto __14
	__14:
	}
	{
		i3 = uint32_t(0)
	__15:
		if !(i3 < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches) {
			goto __17
		}
		*(*uint32_t)(unsafe.Pointer(bp + uintptr(160) + uintptr(d_base_from_value(tls, int32(*(*uint32_t)(unsafe.Pointer(s + 80096 + uintptr(i3)*4)))))*4))++
		goto __16
	__16:
		i3++
		goto __15
		goto __17
	__17:
	}
	{
		i4 = uint32_t(0)
	__18:
		if !(i4 < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals) {
			goto __20
		}
		*(*uint32_t)(unsafe.Pointer(bp + uintptr(416) + uintptr(*(*uint8_t)(unsafe.Pointer(s + 120096 + uintptr(i4))))*4))++
		goto __19
	__19:
		i4++
		goto __18
		goto __20
	__20:
	}

	// Make sure we have enough room for a _full_ V2 header
	if !((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst+uintptr(uint64(unsafe.Sizeof(lzfse_compressed_block_header_v2{}))) > (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst_end) {
		goto __21
	}
	ok = 0
	goto END
__21:
	;
	header2 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst

	// Setup header V1
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).magic = uint32_t(0x31787662)
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).n_raw_bytes = m_sum + l_sum
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).n_matches = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).n_literals = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals

	// Normalize occurrence tables to freq tables
	fse_normalize_freq(tls, 64, 20, bp,
		bp+uintptr(1440)+50)
	fse_normalize_freq(tls, 64, 20, bp+uintptr(80),
		bp+uintptr(1440)+90)
	fse_normalize_freq(tls, 256, 64, bp+uintptr(160),
		bp+uintptr(1440)+130)
	fse_normalize_freq(tls, 1024, 256,
		bp+uintptr(416), bp+uintptr(1440)+258)

	// Compress freq tables to V2 header, and get actual size of V2 header
	**(**uintptr)(unsafe.Pointer(uintptr(s + 40))) += uintptr(lzfse_encode_v1_freq_table(tls, header2, bp+uintptr(1440)))

	// Initialize encoder tables from freq tables
	fse_init_encoder_table(tls, 64, 20,
		bp+uintptr(1440)+50, bp+uintptr(2212))
	fse_init_encoder_table(tls, 64, 20,
		bp+uintptr(1440)+90, bp+uintptr(2372))
	fse_init_encoder_table(tls, 256, 64,
		bp+uintptr(1440)+130, bp+uintptr(2532))
	fse_init_encoder_table(tls, 1024,
		256, bp+uintptr(1440)+258,
		bp+uintptr(3044))

	// Encode literals

	fse_out_init64(tls, bp+uintptr(5096))
	**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5118)) /* state0 */) = libc.AssignPtrUint16(bp+uintptr(5116) /* state1 */, libc.AssignPtrUint16(bp+uintptr(5114) /* state2 */, libc.AssignPtrUint16(bp+uintptr(5112) /* state3 */, fse_state(0))))

	**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5120)) /* buf */) = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst
	i5 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals // I multiple of 4
	// We encode starting from the last literal so we can decode starting from
	// the first
__22:
	if !(i5 > uint32_t(0)) {
		goto __23
	}
	if !(uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5120))))+uintptr(16) > (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst_end) {
		goto __24
	}
	ok = 0
	goto END
__24:
	; // out full
	i5 = i5 - uint32_t(4)
	fse_encode(tls, bp+uintptr(5112), bp+uintptr(3044), bp+uintptr(5096), *(*uint8_t)(unsafe.Pointer(s + 120096 + uintptr(i5+uint32_t(3))))) // 10b
	fse_encode(tls, bp+uintptr(5114), bp+uintptr(3044), bp+uintptr(5096), *(*uint8_t)(unsafe.Pointer(s + 120096 + uintptr(i5+uint32_t(2))))) // 10b
	fse_encode(tls, bp+uintptr(5116), bp+uintptr(3044), bp+uintptr(5096), *(*uint8_t)(unsafe.Pointer(s + 120096 + uintptr(i5+uint32_t(1))))) // 10b
	fse_encode(tls, bp+uintptr(5118), bp+uintptr(3044), bp+uintptr(5096), *(*uint8_t)(unsafe.Pointer(s + 120096 + uintptr(i5+uint32_t(0))))) // 10b
	fse_out_flush64(tls, bp+uintptr(5096), bp+uintptr(5120))
	goto __22
__23:
	;
	fse_out_finish64(tls, bp+uintptr(5096), bp+uintptr(5120))

	// Update header with final encoder state
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).literal_bits = (*fse_out_stream)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5096) /* &out */)).accum_nbits // [-7, 0]
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).n_literal_payload_bytes = uint32_t((int64(uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5120))))) - int64((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst)) / 1)
	*(*uint16_t)(unsafe.Pointer(bp + uintptr(1440) + 32)) = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5118)) /* state0 */))
	*(*uint16_t)(unsafe.Pointer(bp + uintptr(1440) + 32 + 1*2)) = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5116)) /* state1 */))
	*(*uint16_t)(unsafe.Pointer(bp + uintptr(1440) + 32 + 2*2)) = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5114)) /* state2 */))
	*(*uint16_t)(unsafe.Pointer(bp + uintptr(1440) + 32 + 3*2)) = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5112)) /* state3 */))

	// Update state
	(*lzfse_encoder_state)(unsafe.Pointer(s)).dst = uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5120)) /* buf */))

	// literals

	// Encode L,M,D

	fse_out_init64(tls, bp+uintptr(5128))
	**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5148)) /* l_state */) = libc.AssignPtrUint16(bp+uintptr(5146) /* m_state */, libc.AssignPtrUint16(bp+uintptr(5144) /* d_state */, fse_state(0)))

	**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5152)) /* buf1 */) = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst
	i6 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches

	// Add 8 padding bytes to the L,M,D payload
	if !(uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5152))))+uintptr(8) > (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst_end) {
		goto __25
	}
	ok = 0
	goto END
__25:
	; // out full
	store8(tls, uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5152)) /* buf1 */)), uint64(0))
	**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5152)) /* buf1 */) += uintptr(8)

	// We encode starting from the last match so we can decode starting from the
	// first
__26:
	if !(i6 > uint32_t(0)) {
		goto __27
	}
	if !(uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5152))))+uintptr(16) > (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst_end) {
		goto __28
	}
	ok = 0
	goto END
__28:
	; // out full
	i6 = i6 - uint32_t(1)

	// D requires 23b max
	d_value = int32_t(*(*uint32_t)(unsafe.Pointer(s + 80096 + uintptr(i6)*4)))
	d_symbol = d_base_from_value(tls, d_value)
	d_nbits = int32_t(d_extra_bits6[d_symbol])
	d_bits = d_value - d_base_value6[d_symbol]
	fse_out_push64(tls, bp+uintptr(5128), d_nbits, uint64(d_bits))
	fse_encode(tls, bp+uintptr(5144), bp+uintptr(2532), bp+uintptr(5128), d_symbol)

	// M requires 17b max
	m_value = int32_t(*(*uint32_t)(unsafe.Pointer(s + 40096 + uintptr(i6)*4)))
	m_symbol = m_base_from_value(tls, m_value)
	m_nbits = int32_t(m_extra_bits6[m_symbol])
	m_bits = m_value - m_base_value6[m_symbol]
	fse_out_push64(tls, bp+uintptr(5128), m_nbits, uint64(m_bits))
	fse_encode(tls, bp+uintptr(5146), bp+uintptr(2372), bp+uintptr(5128), m_symbol)

	// L requires 14b max
	l_value = int32_t(*(*uint32_t)(unsafe.Pointer(s + 96 + uintptr(i6)*4)))
	l_symbol = l_base_from_value(tls, l_value)
	l_nbits = int32_t(l_extra_bits6[l_symbol])
	l_bits = l_value - l_base_value6[l_symbol]
	fse_out_push64(tls, bp+uintptr(5128), l_nbits, uint64(l_bits))
	fse_encode(tls, bp+uintptr(5148), bp+uintptr(2212), bp+uintptr(5128), l_symbol)
	fse_out_flush64(tls, bp+uintptr(5128), bp+uintptr(5152))
	goto __26
__27:
	;
	fse_out_finish64(tls, bp+uintptr(5128), bp+uintptr(5152))

	// Update header with final encoder state
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).n_lmd_payload_bytes = uint32_t((int64(uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5152))))) - int64((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst)) / 1)
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).lmd_bits = (*fse_out_stream)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5128) /* &out1 */)).accum_nbits // [-7, 0]
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).l_state = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5148)) /* l_state */))
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).m_state = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5146)) /* m_state */))
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).d_state = fse_state(**(**fse_state)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5144)) /* d_state */))

	// Update state
	(*lzfse_encoder_state)(unsafe.Pointer(s)).dst = uintptr(**(**uintptr)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(5152)) /* buf1 */))

	// L,M,D

	// Final state update, here we had enough space in DST, and are not going to
	// revert state
	(*lzfse_encoder_state)(unsafe.Pointer(s)).n_literals = uint32_t(0)
	(*lzfse_encoder_state)(unsafe.Pointer(s)).n_matches = uint32_t(0)

	// Final payload size
	(*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(1440) /* &header1 */)).n_payload_bytes = (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(1440))).n_literal_payload_bytes + (*lzfse_compressed_block_header_v1)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(1440))).n_lmd_payload_bytes

	// Encode state info in V2 header (we previously encoded the tables, now we
	// set the other fields)
	lzfse_encode_v1_state(tls, header2, bp+uintptr(1440))

END:
	if !!(ok != 0) {
		goto __29
	}
	// Revert state, DST was full

	// Revert the d_prev encoding
	d_prev1 = uint32_t(0)
	{
		i7 = uint32_t(0)
	__30:
		if !(i7 < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches) {
			goto __32
		}
		d1 = *(*uint32_t)(unsafe.Pointer(s + 80096 + uintptr(i7)*4))
		if !(d1 == uint32_t(0)) {
			goto __33
		}
		*(*uint32_t)(unsafe.Pointer(s + 80096 + uintptr(i7)*4)) = d_prev1
		goto __34
	__33:
		d_prev1 = d1
	__34:
		;
		goto __31
	__31:
		i7++
		goto __30
		goto __32
	__32:
	}

	// Revert literal count
	(*lzfse_encoder_state)(unsafe.Pointer(s)).n_literals = n_literals0

	// Revert DST
	(*lzfse_encoder_state)(unsafe.Pointer(s)).dst = dst0

	return -2 // DST full
__29:
	;

	return 0
}

// ! @abstract Push a L,M,D match into the STATE.
// @return LZFSE_STATUS_OK if OK.
// @return LZFSE_STATUS_DST_FULL if the match can't be pushed, meaning one of
// the buffers is full. In that case the state is not modified.
func lzfse_push_lmd(tls *libc.TLS, s uintptr, L uint32_t, M uint32_t, D uint32_t) int32 { /* lzfse_encode_base.c:425:19: */
	// Check if we have enough space to push the match (we add some margin to copy
	// literals faster here, and round final count later)
	if (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches+uint32_t(1)+uint32_t(8) > uint32_t(10000) {
		return -2
	} // state full
	if (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals+L+uint32_t(16) > uint32_t(4*10000) {
		return -2
	} // state full

	// Store match
	var n uint32_t = libc.PostIncUint32(&(*lzfse_encoder_state)(unsafe.Pointer(s)).n_matches, 1)
	*(*uint32_t)(unsafe.Pointer(s + 96 + uintptr(n)*4)) = L
	*(*uint32_t)(unsafe.Pointer(s + 40096 + uintptr(n)*4)) = M
	*(*uint32_t)(unsafe.Pointer(s + 80096 + uintptr(n)*4)) = D

	// Store literals
	var dst uintptr = s + 120096 + uintptr((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals)
	var src uintptr = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src + uintptr((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal)
	var dst_end uintptr = dst + uintptr(L)
	if (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal+lzfse_offset(L)+int64(16) > (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_end {
		// Careful at the end of SRC, we can't read 16 bytes
		if L > uint32_t(0) {
			libc.X__builtin___memcpy_chk(tls, dst, src, uint64(L), libc.X__builtin_object_size(tls, dst, 0))
		}
	} else {
		copy16(tls, dst, src)
		dst += uintptr(16)
		src += uintptr(16)
		for dst < dst_end {
			copy16(tls, dst, src)
			dst += uintptr(16)
			src += uintptr(16)
		}
	}
	*(*uint32_t)(unsafe.Pointer(s + 92)) += L

	// Update state
	*(*lzfse_offset)(unsafe.Pointer(s + 16)) += lzfse_offset(L + M)

	return 0
}

// ! @abstract Split MATCH into one or more L,M,D parts, and push to STATE.
// @return LZFSE_STATUS_OK if OK.
// @return LZFSE_STATUS_DST_FULL if the match can't be pushed, meaning one of the
// buffers is full. In that case the state is not modified.
func lzfse_push_match(tls *libc.TLS, s uintptr, match uintptr) int32 { /* lzfse_encode_base.c:470:12: */
	// Save the initial n_matches, n_literals, src_literal
	var n_matches0 uint32_t
	var n_literals0 uint32_t
	var src_literals0 lzfse_offset

	// L,M,D
	var L uint32_t
	_ = L // literal count
	var M uint32_t
	_ = M          // match length
	var D uint32_t // match distance
	var ok int32
	n_matches0 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_matches
	n_literals0 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).n_literals
	src_literals0 = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal
	L = uint32_t((**(**lzfse_match)(unsafe.Pointer(&match))).pos - (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal)
	M = (**(**lzfse_match)(unsafe.Pointer(&match))).length
	D = uint32_t((**(**lzfse_match)(unsafe.Pointer(&match))).pos - (**(**lzfse_match)(unsafe.Pointer(&match))).ref)
	ok = 1

	// Split L if too large
__1:
	if !(L > uint32_t(315)) {
		goto __2
	}
	if !(lzfse_push_lmd(tls, s, uint32(315), uint32(0), uint32(1)) != 0) {
		goto __3
	}
	ok = 0
	goto END
__3:
	; // take D=1 because most frequent, but not actually used
	L = L - uint32_t(315)
	goto __1
__2:
	;

	// Split if M too large
__4:
	if !(M > uint32_t(2359)) {
		goto __5
	}
	if !(lzfse_push_lmd(tls, s, L, uint32(2359), D) != 0) {
		goto __6
	}
	ok = 0
	goto END
__6:
	;
	L = uint32_t(0)
	M = M - uint32_t(2359)
	goto __4
__5:
	;

	// L,M in range
	if !(L > uint32_t(0) || M > uint32_t(0)) {
		goto __7
	}
	if !(lzfse_push_lmd(tls, s, L, M, D) != 0) {
		goto __8
	}
	ok = 0
	goto END
__8:
	;
	L = libc.AssignUint32(&M, uint32_t(0))
	_ = L
	_ = M // dead stores
__7:
	;

END:
	if !!(ok != 0) {
		goto __9
	}
	// Revert state
	(*lzfse_encoder_state)(unsafe.Pointer(s)).n_matches = n_matches0
	(*lzfse_encoder_state)(unsafe.Pointer(s)).n_literals = n_literals0
	(*lzfse_encoder_state)(unsafe.Pointer(s)).src_literal = src_literals0

	return -2 // state tables full
__9:
	;

	return 0 // OK
}

// ! @abstract Backend: add MATCH to state S. Encode block if necessary, when
// state is full.
// @return LZFSE_STATUS_OK if OK.
// @return LZFSE_STATUS_DST_FULL if the match can't be added, meaning one of the
// buffers is full. In that case the state is not modified.
func lzfse_backend_match(tls *libc.TLS, s uintptr, match uintptr) int32 { /* lzfse_encode_base.c:530:12: */
	// Try to push the match in state
	if lzfse_push_match(tls, s, match) == 0 {
		return 0
	} // OK, match added to state

	// Here state tables are full, try to emit block
	if lzfse_encode_matches(tls, s) != 0 {
		return -2
	} // DST full, match not added

	// Here block has been emitted, re-try to push the match in state
	return lzfse_push_match(tls, s, match)
}

// ! @abstract Backend: add L literals to state S. Encode block if necessary,
// when state is full.
// @return LZFSE_STATUS_OK if OK.
// @return LZFSE_STATUS_DST_FULL if the literals can't be added, meaning one of
// the buffers is full. In that case the state is not modified.
func lzfse_backend_literals(tls *libc.TLS, s uintptr, L lzfse_offset) int32 { /* lzfse_encode_base.c:549:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// Create a fake match with M=0, D=1
	// var match lzfse_match at bp, 24

	var pos lzfse_offset = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal + L
	(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &match */)).pos = pos
	(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &match */)).ref = (*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))))).pos - int64(1)
	(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) /* &match */)).length = uint32_t(0)
	return lzfse_backend_match(tls, s, bp)
}

// ! @abstract Backend: flush final block, and emit end of stream
// @return LZFSE_STATUS_OK if OK.
// @return LZFSE_STATUS_DST_FULL if either the final block, or the end-of-stream
// can't be added, meaning one of the buffers is full. If the block was emitted,
// the state is updated to reflect this. Otherwise, it is left unchanged.
func lzfse_backend_end_of_stream(tls *libc.TLS, s uintptr) int32 { /* lzfse_encode_base.c:564:12: */
	// Final match triggers write, otherwise emit blocks when we have enough
	// matches stored
	if lzfse_encode_matches(tls, s) != 0 {
		return -2
	} // DST full

	// Emit end-of-stream block
	if (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst+uintptr(4) > (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst_end {
		return -2
	} // DST full
	store4(tls, (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).dst, uint32(0x24787662))
	**(**uintptr)(unsafe.Pointer(uintptr(s + 40))) += uintptr(4)

	return 0 // OK
}

// ===============================================================
// Encoder state management

//! @abstract Initialize state:
//  @code
//  - hash table with all invalid pos, and value 0.
//  - pending match to NO_MATCH.
//  - src_literal to 0.
//  - d_prev to 0.
//  @endcode
//  * @return LZFSE_STATUS_OK
func lzfse_encode_init(tls *libc.TLS, s uintptr) int32 { /* lzfse_encode_base.c:590:5: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var NO_MATCH = lzfse_match{}
	// var line lzfse_history_set at bp, 32

	{
		var i int32 = 0
	__1:
		if !(i < 4) {
			goto __3
		}
		{
			*(*int32_t)(unsafe.Pointer(bp + uintptr(i)*4)) = -4 * 262139 // invalid pos
			*(*uint32_t)(unsafe.Pointer(bp + 16 + uintptr(i)*4)) = uint32_t(0)

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}
	// Fill table
	{
		var i1 int32 = 0
	__4:
		if !(i1 < int32(1)<<14) {
			goto __6
		}
		*(*lzfse_history_set)(unsafe.Pointer(s + 160096 + uintptr(i1)*32)) = lzfse_history_set(**(**lzfse_history_set)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* line */))
		goto __5
	__5:
		i1++
		goto __4
		goto __6
	__6:
	}
	(*lzfse_encoder_state)(unsafe.Pointer(s)).pending = NO_MATCH
	(*lzfse_encoder_state)(unsafe.Pointer(s)).src_literal = int64(0)

	return 0 // OK
}

// ! @abstract Translate state \p src forward by \p delta > 0.
// Offsets in \p src are updated backwards to point to the same positions.
// @return  LZFSE_STATUS_OK
func lzfse_encode_translate(tls *libc.TLS, s uintptr, delta lzfse_offset) int32 { /* lzfse_encode_base.c:609:5: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!(delta >= int64(0))), int64(0)) != 0 {
		libc.X__assert_rtn(tls, uintptr(unsafe.Pointer(&__func__90)), ts+uintptr(1004), 610, ts+uintptr(1159))
	} else {
	}
	if delta == int64(0) {
		return 0
	} // OK

	// SRC
	**(**uintptr)(unsafe.Pointer(uintptr(s))) += uintptr(delta)

	// Offsets in SRC
	*(*lzfse_offset)(unsafe.Pointer(s + 8)) -= delta
	*(*lzfse_offset)(unsafe.Pointer(s + 24)) -= delta
	*(*lzfse_offset)(unsafe.Pointer(s + 32)) -= delta
	*(*lzfse_offset)(unsafe.Pointer(s + 16)) -= delta

	// Pending match
	*(*lzfse_offset)(unsafe.Pointer(s + 64)) -= delta
	*(*lzfse_offset)(unsafe.Pointer(s + 64 + 8)) -= delta

	// history_table positions, translated, and clamped to invalid pos
	var invalidPos int32_t = -4 * 262139
	{
		var i int32 = 0
	__1:
		if !(i < int32(1)<<14) {
			goto __3
		}
		{
			var p uintptr = s + 160096 + uintptr(i)*32
			{
				var j int32 = 0
			__4:
				if !(j < 4) {
					goto __6
				}
				{
					var newPos lzfse_offset = lzfse_offset(*(*int32_t)(unsafe.Pointer(p + uintptr(j)*4))) - delta // translate
					*(*int32_t)(unsafe.Pointer(p + uintptr(j)*4)) = func() int32 {
						if newPos < lzfse_offset(invalidPos) {
							return invalidPos
						}
						return int32(newPos)
					}() // clamp

				}
				goto __5
			__5:
				j++
				goto __4
				goto __6
			__6:
			}

		}
		goto __2
	__2:
		i++
		goto __1
		goto __3
	__3:
	}

	return 0 // OK
}

var __func__90 = *(*[23]int8)(unsafe.Pointer(ts + uintptr(1170))) /* lzfse_encode_base.c:609:72 */

// ===============================================================
// Encoder front end

func lzfse_encode_base(tls *libc.TLS, s uintptr) int32 { /* lzfse_encode_base.c:643:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var history_table uintptr
	var hashLine uintptr
	// var newH lzfse_history_set at bp, 32

	var NO_MATCH lzfse_match
	var ok int32
	var k int32
	var k1 int32
	var d uint64_t
	var d1 uint32_t // no 4 byte match
	var ref int32_t // too far

	var src_ref uintptr
	var src_pos uintptr
	var length uint32_t
	var maxLength uint32_t
	// We may still want to emit some literals here, to not lag too far behind
	// the current search point, and avoid
	// ending up with a literal block not fitting in the state.
	var n_literals lzfse_offset
	var pos lzfse_offset // pos >= 0

	// Load 4 byte value and get hash line
	var x uint32_t
	// var h lzfse_history_set at bp+uintptr(32), 32

	// Search best incoming match
	// var incoming lzfse_match at bp+uintptr(64), 24

	var k2 int32
	history_table = s + 160096 /* &.history_table */
	hashLine = uintptr(0)
	NO_MATCH = lzfse_match{}
	ok = 1

	libc.X__builtin___memset_chk(tls, bp, 0x00, uint64(unsafe.Sizeof(lzfse_history_set{})), libc.X__builtin_object_size(tls, bp, 0))

	// 8 byte padding at end of buffer
	(*lzfse_encoder_state)(unsafe.Pointer(s)).src_encode_end = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_end - int64(8)
__1:
	if !((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_encode_i < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_encode_end) {
		goto __3
	}
	pos = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_encode_i
	x = load4(tls, (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src+uintptr(pos))
	hashLine = history_table + uintptr(hashX(tls, x))*32
	**(**lzfse_history_set)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(32)) /* h */) = *(*lzfse_history_set)(unsafe.Pointer(hashLine))

	// Prepare next hash line (component 0 is the most recent) to prepare new
	// entries (stored later)

	*(*int32_t)(unsafe.Pointer(bp)) = int32_t(pos)
	{
		k = 0
	__4:
		if !(k < 4-1) {
			goto __6
		}
		*(*int32_t)(unsafe.Pointer(bp + uintptr(k+1)*4)) = *(*int32_t)(unsafe.Pointer(bp + uintptr(32) + uintptr(k)*4))
		goto __5
	__5:
		k++
		goto __4
		goto __6
	__6:
	}
	*(*uint32_t)(unsafe.Pointer(bp + 16)) = x
	{
		k1 = 0
	__7:
		if !(k1 < 4-1) {
			goto __9
		}
		*(*uint32_t)(unsafe.Pointer(bp + 16 + uintptr(k1+1)*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(32) + 16 + uintptr(k1)*4))
		goto __8
	__8:
		k1++
		goto __7
		goto __9
	__9:
	}

	// Do not look for a match if we are still covered by a previous match
	if !(pos < (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal) {
		goto __10
	}
	goto END_POS
__10:
	;
	**(**lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(64)) /* incoming */) = lzfse_match{pos: pos}

	// Check for matches.  We consider matches of length >= 4 only.
	{
		k2 = 0
	__11:
		if !(k2 < 4) {
			goto __13
		}
		d1 = *(*uint32_t)(unsafe.Pointer(bp + uintptr(32) + 16 + uintptr(k2)*4)) ^ x
		if !(d1 != 0) {
			goto __14
		}
		goto __12
	__14:
		; // no 4 byte match
		ref = *(*int32_t)(unsafe.Pointer(bp + uintptr(32) + uintptr(k2)*4))
		if !(lzfse_offset(ref+262139) < pos) {
			goto __15
		}
		goto __12
	__15:
		; // too far

		src_ref = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src + uintptr(ref)
		src_pos = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src + uintptr(pos)
		length = uint32_t(4)
		maxLength =
			uint32_t((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_end - pos - int64(8)) // ensure we don't hit the end of SRC
	__16:
		if !(length < maxLength) {
			goto __17
		}
		d = load8(tls, src_ref+uintptr(length)) ^ load8(tls, src_pos+uintptr(length))
		if !(d == uint64(0)) {
			goto __18
		}
		length = length + uint32_t(8)
		goto __16
	__18:
		;

		length = length + uint32_t(__builtin_ctzll(tls, int64(d))>>3) // ctzll must be called only with D != 0
		goto __17
		goto __16
	__17:
		;
		if !(length > (*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).length) {
			goto __19
		}
		(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(64) /* &incoming */)).length = length
		(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(64) /* &incoming */)).ref = lzfse_offset(ref)
	__19:
		; // keep if longer
		goto __12
	__12:
		k2++
		goto __11
		goto __13
	__13:
	}

	// No incoming match?
	if !((*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).length == uint32_t(0)) {
		goto __20
	}
	// We may still want to emit some literals here, to not lag too far behind
	// the current search point, and avoid
	// ending up with a literal block not fitting in the state.
	n_literals = pos - (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal
	// The threshold here should be larger than a couple of MAX_L_VALUE, and
	// much smaller than LITERALS_PER_BLOCK
	if !(n_literals > int64(8*315)) {
		goto __21
	}
	// Here, we need to consume some literals. Emit pending match if there
	// is one
	if !((*lzfse_encoder_state)(unsafe.Pointer(s)).pending.length > uint32_t(0)) {
		goto __22
	}
	if !(lzfse_backend_match(tls, s, s+64) != 0) {
		goto __24
	}
	ok = 0
	goto END
__24:
	;
	(*lzfse_encoder_state)(unsafe.Pointer(s)).pending = NO_MATCH
	goto __23
__22:
	// No pending match, emit a full LZFSE_ENCODE_MAX_L_VALUE block of
	// literals
	if !(lzfse_backend_literals(tls, s, int64(315)) != 0) {
		goto __25
	}
	ok = 0
	goto END
__25:
	;
__23:
	;
__21:
	;
	goto END_POS // no incoming match
__20:
	;

	// Limit match length (it may still be expanded backwards, but this is
	// bounded by the limit on literals we tested before)
	if !((*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).length > uint32_t(100*2359)) {
		goto __26
	}
	(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(64) /* &incoming */)).length = uint32_t(100 * 2359)
__26:
	;

	// Expand backwards (since this is expensive, we do this for the best match
	// only)
__27:
	if !((*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).pos > (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal && (*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).ref > int64(0) && int32(*(*uint8_t)(unsafe.Pointer((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src + uintptr((*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).ref-int64(1))))) == int32(*(*uint8_t)(unsafe.Pointer((**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src + uintptr((*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).pos-int64(1)))))) {
		goto __28
	}
	(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64) /* &incoming */)).pos--
	(*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64) /* &incoming */)).ref--
	goto __27
__28:
	;
	*(*uint32_t)(unsafe.Pointer(bp + uintptr(64) + 16)) += uint32_t(pos - (*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).pos) // update length after expansion

	// Match filtering heuristic (from LZVN). INCOMING is always defined here.

	// Incoming is 'good', emit incoming
	if !((*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).length >= uint32_t(40)) {
		goto __29
	}
	if !(lzfse_backend_match(tls, s, bp+uintptr(64)) != 0) {
		goto __30
	}
	ok = 0
	goto END
__30:
	;
	(*lzfse_encoder_state)(unsafe.Pointer(s)).pending = NO_MATCH
	goto END_POS
__29:
	;

	// No pending, keep incoming
	if !((*lzfse_encoder_state)(unsafe.Pointer(s)).pending.length == uint32_t(0)) {
		goto __31
	}
	(*lzfse_encoder_state)(unsafe.Pointer(s)).pending = lzfse_match(**(**lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(64)) /* incoming */))
	goto END_POS
__31:
	;

	// No overlap, emit pending, keep incoming
	if !((*lzfse_encoder_state)(unsafe.Pointer(s)).pending.pos+lzfse_offset((*lzfse_encoder_state)(unsafe.Pointer(s)).pending.length) <= (*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).pos) {
		goto __32
	}
	if !(lzfse_backend_match(tls, s, s+64) != 0) {
		goto __33
	}
	ok = 0
	goto END
__33:
	;
	(*lzfse_encoder_state)(unsafe.Pointer(s)).pending = lzfse_match(**(**lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp))) + uintptr(64)) /* incoming */))
	goto END_POS
__32:
	;

	// Overlap: emit longest
	if !((*lzfse_match)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))+uintptr(64))).length > (*lzfse_encoder_state)(unsafe.Pointer(s)).pending.length) {
		goto __34
	}
	if !(lzfse_backend_match(tls, s, bp+uintptr(64)) != 0) {
		goto __36
	}
	ok = 0
	goto END
__36:
	;
	goto __35
__34:
	if !(lzfse_backend_match(tls, s, s+64) != 0) {
		goto __37
	}
	ok = 0
	goto END
__37:
	;
__35:
	;
	(*lzfse_encoder_state)(unsafe.Pointer(s)).pending = NO_MATCH

END_POS:
	// We are done with this src_encode_i.
	// Update state now (s->pending has already been updated).
	*(*lzfse_history_set)(unsafe.Pointer(hashLine)) = lzfse_history_set(**(**lzfse_history_set)(unsafe.Pointer(uintptr(**(**unsafe.Pointer)(unsafe.Pointer(&bp)))) /* newH */))
	goto __2
__2:
	(*lzfse_encoder_state)(unsafe.Pointer(s)).src_encode_i++
	goto __1
	goto __3
__3:
	;

END:
	if ok != 0 {
		return 0
	}
	return -2
}

func lzfse_encode_finish(tls *libc.TLS, s uintptr) int32 { /* lzfse_encode_base.c:808:5: */
	var NO_MATCH = lzfse_match{}

	// Emit pending match
	if (*lzfse_encoder_state)(unsafe.Pointer(s)).pending.length > uint32_t(0) {
		if lzfse_backend_match(tls, s, s+64) != 0 {
			return -2
		}
		(*lzfse_encoder_state)(unsafe.Pointer(s)).pending = NO_MATCH
	}

	// Emit final literals if any
	var L lzfse_offset = (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_end - (**(**lzfse_encoder_state)(unsafe.Pointer(&s))).src_literal
	if L > int64(0) {
		if lzfse_backend_literals(tls, s, L) != 0 {
			return -2
		}
	}

	// Emit all matches, and end-of-stream block
	if lzfse_backend_end_of_stream(tls, s) != 0 {
		return -2
	}

	return 0
}

var ts1 = "/Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_fse.h\x00s->accum_nbits >= 0 && s->accum_nbits <= 7\x00s->accum_nbits == 64 || (s->accum >> s->accum_nbits) == 0\x00fse_out_flush64\x00s->accum_nbits >= -7 && s->accum_nbits <= 0\x00fse_out_finish64\x00s->accum_nbits >= 0 && s->accum_nbits <= 64\x00fse_out_push64\x00s->accum_nbits >= 56 && s->accum_nbits < 64\x00(s->accum >> s->accum_nbits) == 0\x00fse_in_checked_flush64\x00n >= 0 && n <= s->accum_nbits\x00fse_in_pull64\x00/Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_internal.h\x00lsb < container_width\x00width > 0 && width <= container_width\x00lsb + width <= container_width\x00extract\x00/Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_decode_base.c\x00offset + nbits < 64 && offset >= 0 && nbits <= 32\x00get_field\x00l_state < LZFSE_ENCODE_L_STATES\x00m_state < LZFSE_ENCODE_M_STATES\x00d_state < LZFSE_ENCODE_D_STATES\x00lzfse_decode_lmd\x00/Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_fse.c\x00nsymbols <= 256\x00fse_check_freq(freq, nsymbols, nstates) == 0\x00fse_init_decoder_table\x00fse_init_value_decoder_table\x00/Users/zchee/src/github.com/lzfse/lzfse/src/lzfse_encode_base.c\x00nbits == 32 || (v < (1U << nbits))\x00setField\x00bits < (1 << nbits)\x00lzfse_encode_v1_freq_table\x00delta >= 0\x00lzfse_encode_translate\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
